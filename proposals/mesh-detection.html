<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>

  <meta http-equiv="origin-trial"
    content="Ahfj+MLeL6bh+LNmpnSdepftxoDHHwjUG2KWZ4jjCb1WoZxtBlzF3cDHuJNVqnhr3HXJwQ+kLaw57NO15S0mRwwAAABkeyJvcmlnaW4iOiJodHRwczovL2ltbWVyc2l2ZS13ZWIuZ2l0aHViLmlvOjQ0MyIsImZlYXR1cmUiOiJXZWJYUlBsYW5lRGV0ZWN0aW9uIiwiZXhwaXJ5IjoxNjI5ODQ5NTk5fQ==">

  <title>AR Mesh Detection</title>

  <link href='../css/common.css' rel='stylesheet'>
  </link>
  <script
    type="modele"
    src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"
    crossorigin="anonymous"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1/dist/peerjs.min.js"></script>

</head>

<body>
  <canvas id="mediapipe-canvas"></canvas>
  <video id="segmentVideo" autoplay muted style="display: none;"></video>
  <header>
    <details open>
      <summary>AR Mesh Detection</summary>
      This sample demonstrates using the
      <a href="https://immersive-web.github.io/real-world-meshing/">>Mesh Detection feature</a>
      including an implementation of synchronous hit test in JavaScript
      that leverages obtained mesh data to position objects.
      <p>
        <input id="showMeshTriangles" type="checkbox" checked>
        <label for="showMeshTriangles">Mesh triangles visible</label><br />

        <input id="useDomOverlay" type="checkbox" checked>
        <label for="useDomOverlay">Enable DOM Overlay</label><br />

        <a class="back" href="./index.html">Back</a>
      </p>
    </details>
  </header>
  <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>
  <script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
          "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/",
          "three-mesh-ui": "https://unpkg.com/three-mesh-ui@6.5.4/build/three-mesh-ui.module.js"
				}
			}
		</script>

  <script type="module">
    // Code adapted from THREE.js' WebXR hit test sample.
    // THREE.js is covered by MIT license which can be found at:
    // https://github.com/mrdoob/THREE.js/blob/master/LICENSE

    // The code also links to a .png file from ARCore Android SDK.
    // It is covered by Apache 2.0 license which can be found at:
    // https://github.com/google-ar/arcore-android-sdk/blob/c684bbda37e44099c273c3e5274fae6fccee293c/LICENSE

    import * as THREE from 'three';
    import * as ThreeMeshUI from "three-mesh-ui";
    //import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
    import { BoxLineGeometry } from 'three/examples/jsm/geometries/BoxLineGeometry.js';
    //import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    //import VRControl from './utils/VRControl.js';
    import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.min.js';
    import {createText} from 'three/examples/jsm/webxr/Text2D.js';
    import { OculusHandModel } from 'three/examples/jsm/webxr/OculusHandModel.js';
    import { WebXRButton } from '../js/util/webxr-button.js';
    import { hitTest, filterHitTestResults } from '../js/hit-test.js';
    import {
      PoseLandmarker,
      FaceLandmarker,
      DrawingUtils,
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision";
    import { World, System, Component, TagComponent, Types } from 'three/examples/jsm/libs/ecsy.module.js';

    class Object3D extends Component { }

		Object3D.schema = {
			object: { type: Types.Ref }
		};

		class Button extends Component { }

		Button.schema = {
			// button states: [resting, pressed, fully_pressed, recovering]
			currState: { type: Types.String, default: 'resting' },
			prevState: { type: Types.String, default: 'resting' },
			pressSound: { type: Types.Ref, default: null },
			releaseSound: { type: Types.Ref, default: null },
			restingY: { type: Types.Number, default: null },
			surfaceY: { type: Types.Number, default: null },
			recoverySpeed: { type: Types.Number, default: 0.4 },
			fullPressDistance: { type: Types.Number, default: null },
			action: { type: Types.Ref, default: () => { } }
		};

		class ButtonSystem extends System {

			init( attributes ) {

				this.renderer = attributes.renderer;
				this.soundAdded = false;

			}

			execute( /*delta, time*/ ) {

				let buttonPressSound, buttonReleaseSound;
				if ( this.renderer.xr.getSession() && ! this.soundAdded ) {

					const xrCamera = this.renderer.xr.getCamera();

					const listener = new THREE.AudioListener();
					xrCamera.add( listener );

					// create a global audio source
					buttonPressSound = new THREE.Audio( listener );
					buttonReleaseSound = new THREE.Audio( listener );

					// load a sound and set it as the Audio object's buffer
					const audioLoader = new THREE.AudioLoader();
					audioLoader.load( './webxr-hands-examples-main/sounds/button-press.ogg', function ( buffer ) {

						buttonPressSound.setBuffer( buffer );

					} );
					audioLoader.load( './webxr-hands-examples-main/sounds/button-release.ogg', function ( buffer ) {

						buttonReleaseSound.setBuffer( buffer );

					} );
					this.soundAdded = true;

				}

				this.queries.buttons.results.forEach( entity => {

					const button = entity.getMutableComponent( Button );
					const buttonMesh = entity.getComponent( Object3D ).object;
					// populate restingY
					if ( button.restingY == null ) {

						button.restingY = buttonMesh.position.y;

					}

					if ( buttonPressSound ) {

						button.pressSound = buttonPressSound;

					}

					if ( buttonReleaseSound ) {

						button.releaseSound = buttonReleaseSound;

					}

					if ( button.currState == 'fully_pressed' && button.prevState != 'fully_pressed' ) {

						if ( button.pressSound ) button.pressSound.play();
						button.action();

					}

					if ( button.currState == 'recovering' && button.prevState != 'recovering' ) {

						if ( button.releaseSound ) button.releaseSound.play();

					}

					// preserve prevState, clear currState
					// FingerInputSystem will update currState
					button.prevState = button.currState;
					button.currState = 'resting';

				} );

			}

		}

		ButtonSystem.queries = {
			buttons: {
				components: [ Button ]
			}
		};

		class Pressable extends TagComponent { }

		class FingerInputSystem extends System {

			init( attributes ) {

				this.hands = attributes.hands;

			}

			execute( delta/*, time*/ ) {

				this.queries.pressable.results.forEach( entity => {

					const button = entity.getMutableComponent( Button );
					const object = entity.getComponent( Object3D ).object;
					const pressingDistances = [];
					this.hands.forEach( hand => {

						if ( hand && hand.intersectBoxObject( object ) ) {

							const pressingPosition = hand.getPointerPosition();
							pressingDistances.push( button.surfaceY - object.worldToLocal( pressingPosition ).y );

						}

					} );
					if ( pressingDistances.length == 0 ) { // not pressed this frame

						if ( object.position.y < button.restingY ) {

							object.position.y += button.recoverySpeed * delta;
							button.currState = 'recovering';

						} else {

							object.position.y = button.restingY;
							button.currState = 'resting';

						}

					} else {

						button.currState = 'pressed';
						const pressingDistance = Math.max( pressingDistances );
						if ( pressingDistance > 0 ) {

							object.position.y -= pressingDistance;

						}

						if ( object.position.y <= button.restingY - button.fullPressDistance ) {

							button.currState = 'fully_pressed';
							object.position.y = button.restingY - button.fullPressDistance;

						}

					}

				} );

			}

		}

		FingerInputSystem.queries = {
			pressable: {
				components: [ Pressable ]
			}
		};

		class Rotating extends TagComponent { }

		class RotatingSystem extends System {

			execute( delta/*, time*/ ) {

				this.queries.rotatingObjects.results.forEach( entity => {

					const object = entity.getComponent( Object3D ).object;
					object.rotation.x += 0.4 * delta;
					object.rotation.y += 0.4 * delta;

				} );

			}

		}

		RotatingSystem.queries = {
			rotatingObjects: {
				components: [ Rotating ]
			}
		};

		class HandsInstructionText extends TagComponent { }

		class InstructionSystem extends System {

			init( attributes ) {

				this.controllers = attributes.controllers;

			}

			execute( /*delta, time*/ ) {

				let visible = false;
				this.controllers.forEach( controller => {

					if ( controller.visible ) {

						visible = true;

					}

				} );

				this.queries.instructionTexts.results.forEach( entity => {

					const object = entity.getComponent( Object3D ).object;
					object.visible = visible;

				} );

			}

		}

		InstructionSystem.queries = {
			instructionTexts: {
				components: [ HandsInstructionText ]
			}
		};

		class OffsetFromCamera extends Component { }

		OffsetFromCamera.schema = {
			x: { type: Types.Number, default: 0 },
			y: { type: Types.Number, default: 0 },
			z: { type: Types.Number, default: 0 },
		};

		class NeedCalibration extends TagComponent { }

		class CalibrationSystem extends System {

			init( attributes ) {

				this.camera = attributes.camera;
				this.renderer = attributes.renderer;

			}

			execute( /*delta, time*/ ) {

				this.queries.needCalibration.results.forEach( entity => {

					if ( this.renderer.xr.getSession() ) {

						const offset = entity.getComponent( OffsetFromCamera );
						const object = entity.getComponent( Object3D ).object;
						const xrCamera = this.renderer.xr.getCamera();
						object.position.x = xrCamera.position.x + offset.x;
						object.position.y = xrCamera.position.y + offset.y;
						object.position.z = xrCamera.position.z + offset.z;
						entity.removeComponent( NeedCalibration );

					}

				} );

			}

		}

		CalibrationSystem.queries = {
			needCalibration: {
				components: [ NeedCalibration ]
			}
		};

    const world = new World();
		const clock = new THREE.Clock();

    const showMeshTriangles = document.getElementById('showMeshTriangles');

    const allMeshOrigins = [];

    function updateState() {
      const createMeshMaterial = (params) =>
        new THREE.MeshBasicMaterial(Object.assign(params, {
          opacity: 0.15,
          transparent: true,
          //depthTest: true
        }));

      meshMaterials.splice(0, meshMaterials.length)
      if (showMeshTriangles.checked) {
        // preallocate colors for various meshes  
        meshMaterials.push(createMeshMaterial({ color: 0xff0000 }));
        meshMaterials.push(createMeshMaterial({ color: 0x00ff00 }));
        meshMaterials.push(createMeshMaterial({ color: 0x0000ff }));
        meshMaterials.push(createMeshMaterial({ color: 0xffff00 }));
        meshMaterials.push(createMeshMaterial({ color: 0x00ffff }));
        meshMaterials.push(createMeshMaterial({ color: 0xff00ff }));
      } else {
        // if the mesh is not visible, set the blending so the mesh "punches"
        // out vr content behind it. This will occlude the VR scene with the 
        // real world.
        let material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.FrontSide });
        material.blending = THREE.CustomBlending;
        material.blendEquation = THREE.AddEquation;
        material.blendSrc = THREE.ZeroFactor;
        material.blendDst = THREE.ZeroFactor;
        material.depthWrite = false;
        //material.depthTest = true;
        meshMaterials.push(material);
      }
    }

    showMeshTriangles.addEventListener('input', element => updateState());

    // Suppress XR events for interactions with the DOM overlay
    document.querySelector('header').addEventListener('beforexrselect', (ev) => {
      console.log(ev.type);
      ev.preventDefault();
    });

    let xrButton = null;
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;

    let container;
    //let camera, scene, renderer, vrControl;
    let camera, scene, renderer;
    let meshContainer, meshes, currentMesh;
    const objsToTest = [];
    let selectState = false;
    const raycaster = new THREE.Raycaster();

    const tempMatrix = new THREE.Matrix4();

    // let reticle;
    // hitResult will be set when reticle is visible:
    let hitResult;

    //let plane;

    let mediapipeCanvas;
    let ctx;
    let video;
    let drawingUtils;

    const peer = new Peer();
    let conn;
    let jsonData;
    let videoWidth;
    let videoHeight;
    let textPlanes = [];

    // UI
    //
    const uiContainer = new THREE.Group();
    let userTexts = [];
    let userText1;
    let userText2;
    let userText3;
    const uiGroup = new THREE.Group();
    const buttonGroup = new THREE.Group();
    const recipeGroup = new THREE.Group();
    const micGroup = new THREE.Group();
    uiGroup.renderOrder = 2;
    buttonGroup.renderOrder = 2;
    recipeGroup.renderOrder = 2;
    micGroup.renderOrder = 2;
    let currentYOffset = 0;
    let textPanelContents = [];
    let lastTips = [];
    let lastCallTime = 0;
    let transcriptResult = "";
    let lastTranscriptResult = null;

    const recipe = [
      "1. Place the pour-over dripper on a mug. Fold a paper filter into a quarter-circle and form a cone inside the dripper. Rinse the filter with cold water, then moisten it completely with hot water to eliminate papery residue and prevent a woodsy taste in the coffee.",
      "2. Lift the dripper and pour out the water. Then set the dripper with the wet filter back on the coffee mug. Measure 12 ounces of cold water and transfer it into the kettle. Heat the kettle water for 3 minutes.",
      "3. Place the tortilla on the cutting board. Fold the tortilla in half into a semi-circle. Use a butter knife to spread a layer of Nutella onto the tortilla. Top with banana slices. Sprinkle a small amount of cinnamon onto the tortilla. Microwave the tortilla for 1 minute.",
      "4. Measure 30 g (3 tablespoons) of coffee beans using a digital scale and grind them to a coarse sand consistency, about 20 seconds. Transfer the grounds to the filter cone and place the mug with the dripper on the scale, setting it to zero.",
      "5. Slowly pour the water over the grounds in a circular motion. Do not overfill beyond the top of the paper filter. Your scale should read 100 g once you've poured enough water into the dripper.",
      "6. Let the coffee drain completely into the mug before removing the dripper. Discard the paper filter and coffee grounds.",
      "7. Take the tortilla out from the microwave. During the coffee draining, slice the tortilla in half using a butter knife to create two triangular wedges. Place tortilla wedges on a plate to serve."
    ];

    let currentRecipeStep = 0;
    let lastSentRecipeStep = null;
    let micValue = 0; // 0: off, 1: on
    let lastSentMicValue = null;
    let shouldShowTips = false;

    // for Testing:
    // textPanelContents[0] = "1. The image shows a tortilla placed on a cutting board.";
    // //push
    // textPanelContents.push("2. The image shows a jar of nut butter.");

    function setupPeerConnection(){
      peer.on("open", (id) => {
        console.log(id);
        conn = peer.connect("4d7a1");
        conn.on("open", () => {
          console.log("Start receiving data");
          conn.on("data", (data) => {
            try {
              // console.log("receiving data");
              jsonData = JSON.parse(data);
              window.jsonData = jsonData;
              //drawData(jsonData);
              //console.log(jsonData);
              videoWidth = jsonData.streamWidth;
              videoHeight = jsonData.streamHeight;

              const newtips = jsonData.tip;
              if (tipsHaveChanged(newtips)) {
                  // Only reset and repopulate textPanelContents if the tips have changed
                  textPanelContents = []; // Reset the contents
                  textPanelContents.push(jsonData.tip);

                  lastTips = newtips; 

                  //clearGroup(uiGroup); // Clear existing UI elements
                  //makeTextPanel(); // Re-create text panels with updated tips
                  shouldShowTips = true;
                  setRecipe();
              }
              transcriptResult = jsonData.transcriptionText;
              
            } catch (e) {
              console.error("Error parsing received JSON:", e);
            }
          });

          conn.send(`step:${currentRecipeStep}`);
          conn.send(`mic:${micValue}`);
          
        });

        // peer.on("call", (call) => {
        //   call.answer();
        //   call.on("stream", (stream) => {
        //     console.log("stream");
        //     video = document.getElementById("segmentVideo");
        //     video.srcObject = stream;
        //     video.play();
        //   });
        // });
      });
    }

    function sendStepIfChanged() {
      if (currentRecipeStep !== lastSentRecipeStep) {
        conn.send(`step:${currentRecipeStep}`);
        lastSentRecipeStep = currentRecipeStep;
      }
    }

    function sendMicValueIfChanged() {
      if (micValue !== lastSentMicValue) {
        conn.send(`mic:${micValue}`);
        lastSentMicValue = micValue;
      }
    }

    function sendTranscriptIfChanged() {
      if (transcriptResult !== lastTranscriptResult) {
        setMicandTranscript();
        lastTranscriptResult = transcriptResult;
      }
    }

    // // 绘制数据
    // function drawData(result) {
    //     ctx.clearRect(0, 0, mediapipeCanvas.width, mediapipeCanvas.height);
    //     if (result.objectDetector) drawObject(result);
    //     updatePlaneMaterial(mediapipeCanvas); // 更新 Three.js 平面的材质
        
    //     // Assuming tips are in result.tipsHistory
    //     let startY = 20; // Start 20 pixels from the top of the canvas
    //     const tipHeight = 20; // Assuming each tip needs 20 pixels of height
    //     for (let tip of result.tipsHistory) {
    //         // Draw the tip text at the current Y position
    //         ctx.fillStyle = "#000000";
    //         ctx.font = "12px Arial";
    //         ctx.fillText(tip.tip, 10, startY); // Draw tip at x=10, y=startY
            
    //         startY += tipHeight; // Move startY down for the next tip
    //     }
    // }

    // // 更新 Three.js 平面的材质
    // function updatePlaneMaterial(textureCanvas) {
    //     const texture = new THREE.CanvasTexture(textureCanvas);
    //     texture.needsUpdate = true;
    //     plane.material.map = texture;
    //     plane.material.needsUpdate = true;
    // }

    // 处理 MediaPipe 检测到的对象
    //-----the same------
    // function drawObject(result) {
    //   for (let detection of result.objectDetector.detections) {
    //     const name = detection.categories[0].categoryName;
    //     const score = Math.round(
    //       parseFloat(detection.categories[0].score) * 100
    //     );
    //     const bbox = detection.boundingBox;
    //     let x = bbox.originX;
    //     let y = bbox.originY;
    //     let width = bbox.width;
    //     let height = bbox.height;
    //     let centerX = x + width / 2;
    //     let centerY = y + height / 2;
    //     //console.log(name, score, x, y, width, height);

    //     ctx.strokeStyle = "#fff";
    //     ctx.fillStyle = "rgba(255, 255, 0, 0.25)";
    //     ctx.lineWidth = 1;
    //     ctx.fillRect(x, y, width, height);
    //     ctx.strokeRect(x, y, width, height);

    //     ctx.fillRect(centerX - 2, centerY - 2, 4, 4);
    //     ctx.strokeRect(centerX - 2, centerY - 2, 4, 4);

    //     ctx.fillStyle = "#007f8b";
    //     ctx.font = "12px Arial";
    //     ctx.fillText(`${name} - ${score}%`, x, y - 10);
    //   }

    //   for (let tip of result.tipsHistory) {
    //     ctx.fillStyle = "#000000";
    //     ctx.font = "12px Arial";
    //     // make the tip at the center of screen
    //     ctx.fillText(tip.tip, mediapipeCanvas.width / 2, mediapipeCanvas.height / 2);
    //     // console.log(tip.tip, tip.row, tip.column);
    //     console.log(tip.tip);
    //   }
    // }

    const meshMaterials = [];
    const wireframeMaterial = new THREE.MeshBasicMaterial({ wireframe: true });
    const baseOriginGroup = new THREE.Group();

    init();
    setupPeerConnection();

    function makeButtonMesh( x, y, z, color ) {

      const geometry = new THREE.BoxGeometry( x, y, z );
      const material = new THREE.MeshPhongMaterial( { color: color } );
      const buttonMesh = new THREE.Mesh( geometry, material );
      buttonMesh.castShadow = true;
      buttonMesh.receiveShadow = true;
      return buttonMesh;

    }

    function setTextPanel(textPanelContent){

      // set background
      const conBlank = new ThreeMeshUI.Block( {
        justifyContent: 'start',  
        contentDirection: 'column',
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
        fontSize: 0.07*0.0789*1.2,
        //bestFit: 'auto',
        padding: 0.10*0.0789*1.2,
        borderWidth: 0.01*0.0789*1.2,
        borderOpacity: 1,
          borderColor: new THREE.Color( 0x6B390A ),
        backgroundColor: new THREE.Color( 0x1E0646 ),
        backgroundOpacity: 0.75,
        borderRadius: 0.11*0.0789*1.2,
        width: 1.9*0.0789*1.2,
        height: 0.5*0.05*2*1.1,
      } );
      conBlank.position.set(0, -0.09 + currentYOffset, 0);
      uiGroup.add(conBlank);

      // set text
      const conText = new ThreeMeshUI.Block( {
      width: 1.9*0.0789*1.2,
      height: 0.5*0.0789*1.2,
      padding: 0.10*0.0789*1.2,
      justifyContent: "center",
      textAlign: "left",
      bestFit: 'grow',

      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      borderColor: new THREE.Color( 0x0D87E0 ),

      backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 0,

      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );

      conText.position.set(0, -0.09 + currentYOffset, -0.01);
      conText.add(
      new ThreeMeshUI.Text({
        content: textPanelContent,
        fontSize: 0.05*0.2*0.8,
      })
      );
      uiGroup.add(conText);

      currentYOffset -= 0.06;
    }

    function makeTextPanel() {
      currentYOffset = 0; // Reset the offset for each update

      // set background
      const containerBlank = new ThreeMeshUI.Block( {
        justifyContent: 'start',  
        contentDirection: 'column',
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
        fontSize: 0.07*0.0789*1.2,
        //bestFit: 'auto',
        padding: 0.10*0.0789*1.2,
        // borderWidth: 0.01*0.0789*1.2,
        // borderOpacity: 1,
        //   borderColor: new THREE.Color( 0x0D87E0 ),
        // backgroundColor: new THREE.Color( 0x1E0646 ),
        backgroundOpacity: 0.5,
        borderRadius: 0.11*0.0789*1.2,
        width: 1.9*0.0789*1.2*2,
        height: 0.5*0.05*4*1.5*0.5,
      } );
      containerBlank.position.set(0, 0.25*0.0789*5-0.03, 0);
      uiGroup.add(containerBlank);

      

      // set text Panel
      const textPreviousPanel = new ThreeMeshUI.Block( {
        width: 0.05,
      height: 0.025,
      padding: 0,
      justifyContent: "center",
      textAlign: "center",
      bestFit: 'auto',
      
      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      //borderColor: new THREE.Color( 0x7421FF ),
      
      //backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 0.75,
      
      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );
      textPreviousPanel.position.set(-0.06, 0.35*0.0789*2.7+0.04-0.1, 0.001);
      textPreviousPanel.add(
        new ThreeMeshUI.Text({
          content: "Previous",
          fontSize: 0.008,
        })
      );
      buttonGroup.add(textPreviousPanel);

      const textMicPanel = new ThreeMeshUI.Block( {
          width: 0.05,
        height: 0.025,
        padding: 0,
        justifyContent: "center",
        textAlign: "center",
        bestFit: 'auto',
        
        borderRadius: 0.11*0.0789*1.2,
        borderWidth: 0.01*0.0789*1.2,
        borderOpacity: 0,
        // borderColor: new THREE.Color( 0x7421FF ),
        
        // backgroundColor: new THREE.Color( 0x19764F ),
        backgroundOpacity: 0.75,
        
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
        } );
  			// textMicPanel.position.set(-0.06, -0.03, 0.001);
        textMicPanel.position.set(0, 0.35*0.0789*2.7+0.04-0.1, -0.005);
        textMicPanel.add(
          new ThreeMeshUI.Text({
            content: "Ask",
            fontSize: 0.008,
          })
        );
        buttonGroup.add(textMicPanel);
      
              
      // set text Panel
      const textNextPanel = new ThreeMeshUI.Block( {
        width: 0.05,
      height: 0.025,
      padding: 0,
      justifyContent: "center",
      textAlign: "center",
      bestFit: 'auto',
      
      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      //borderColor: new THREE.Color( 0x7421FF ),
      
      // backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 0.75,
      
      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );
      textNextPanel.position.set(0.06, 0.35*0.0789*2.7+0.04-0.1, -0.005);
      textNextPanel.add(
        new ThreeMeshUI.Text({
          content: "Next",
          fontSize: 0.008,
        })
      );
      buttonGroup.add(textNextPanel);

      

      // for (let i=0; i<textPanelContents.length; i++){
      // setTextPanel(textPanelContents[i]);
      // //set an offset on Y axis for each text panel
      // //textPanelContents[i].position.set(0, 0.5, 0);
      // }

      // textPanelContents.forEach(content => {
      //   setTextPanel(content);
      // });

    }

    function setRecipe(){
      // set recipe text
      // clear recipe group
      clearGroup(recipeGroup);
      const containerText = new ThreeMeshUI.Block( {
      width: 1.9*0.0789*1.2*2,
      height: 0.5*0.0789*1.2*0.5,
      padding: 0.10*0.0789*1.2,
      justifyContent: "center",
      textAlign: "left",
      bestFit: 'grow',

      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      borderColor: new THREE.Color( 0x0D87E0 ),

      backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 0,

      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );
      containerText.position.set(0, 0.35*0.0789*2.7-0.01, -0.01);
      containerText.add(
        new ThreeMeshUI.Text({
          //if there is textPanelContent, use it, otherwise use recipe[currentRecipeStep]
          content: recipe[currentRecipeStep],
          fontSize: 0.05*0.0789*2,
        }),
        new ThreeMeshUI.Text({
          //if there is textPanelContent, use it, otherwise use recipe[currentRecipeStep]
          content: '\n',
          fontSize: 0.05*0.0789*2,
        })
      );

      if (textPanelContents[0]){
      
        const tipText = new ThreeMeshUI.Block( {
        width: 1.9*0.0789*1.2*2,
        height: 0.5*0.0789*1.2*0.5,
        padding: 0.10*0.0789*1.2,
        justifyContent: "center",
        textAlign: "center",
        bestFit: 'grow',

        borderRadius: 0.11*0.0789*1.2,
        borderWidth: 0.01*0.0789*1.2,
        borderOpacity: 0,
        borderColor: new THREE.Color( 0x0D87E0 ),

        //backgroundColor: new THREE.Color( 0x1E0646 ),
        backgroundOpacity: 0.75,

        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
        } );
        tipText.position.set(0, 0.35*0.0789*2.7+0.08, -0.01);
        tipText.rotateX(10 * Math.PI / 180);

          // Efficiency/Caution/Answer/Recommendation/Check
        if (shouldShowTips && textPanelContents[0] && textPanelContents[0].includes("Efficiency")) {
          tipText.add(
            new ThreeMeshUI.Text({
              content:  textPanelContents[0],
              fontSize: 0.05*0.0789*2*1.5,
              fontColor: new THREE.Color(0x4DEAFF),
            }),
          );
        } else if (shouldShowTips && textPanelContents[0] && textPanelContents[0].includes("Caution")) {
          tipText.add(
            new ThreeMeshUI.Text({
              content:  textPanelContents[0],
              fontSize: 0.05*0.0789*2*1.5,
              fontColor: new THREE.Color(0xFF542E),
            }),
          );
        } else if (shouldShowTips && textPanelContents[0] && textPanelContents[0].includes("Answer")) {
          tipText.add(
            new ThreeMeshUI.Text({
              content:  textPanelContents[0],
              fontSize: 0.05*0.0789*2*1.5,
              fontColor: new THREE.Color(0x2DFF8F),
            }),
          );
        } else if (shouldShowTips && textPanelContents[0] && textPanelContents[0].includes("Recommendation")) {
          tipText.add(
            new ThreeMeshUI.Text({
              content:  textPanelContents[0],
              fontSize: 0.05*0.0789*2*1.5,
              fontColor: new THREE.Color(0xFF49F8),
            }),
          );
        } else if (shouldShowTips && textPanelContents[0] && textPanelContents[0].includes("Check")) {
          tipText.add(
            new ThreeMeshUI.Text({
              content:  textPanelContents[0],
              fontSize: 0.05*0.0789*2*1.5,
              fontColor: new THREE.Color(0xFFA629),
            }),
          );
        }
        recipeGroup.add(tipText);
      }
      recipeGroup.add(containerText);
      //textPanelContents = [];
    }

    // function setMicandTranscript(){
    //   //clearGroup(micGroup);
    //   // set mic background
    //   // const containerMicBlank = new ThreeMeshUI.Block( {
    //   //     justifyContent: 'start',  
    //   //     contentDirection: 'column',
    //   //     fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
    //   //     fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
    //   //     fontSize: 0.07*0.0789*1.2,
    //   //     //bestFit: 'auto',
    //   //     padding: 0.10*0.0789*1.2,
    //   //     borderWidth: 0.01*0.0789*1.2,
    //   //     borderOpacity: 1,
    //   //     borderColor: new THREE.Color( 0x0A6B3D ),
    //   //   	backgroundColor: new THREE.Color( 0x163C2C ),
    //   //     backgroundOpacity: 0.5,
    //   //     borderRadius: 0.11*0.0789*1.2,
    //   //     width: 1.9*0.0789*1.2,
    //   //     height: 0.5*0.05*2*0.8,
    //   //   } );
		// 	//   containerMicBlank.position.set(0, -0.03, 0);
    //   // 	buttonGroup.add(containerMicBlank);
        
    //     // set mic button
    //     // const textMicPanel = new ThreeMeshUI.Block( {
    //     //   width: 0.05,
    //     // height: 0.025,
    //     // padding: 0,
    //     // justifyContent: "center",
    //     // textAlign: "center",
    //     // bestFit: 'auto',
        
    //     // borderRadius: 0.11*0.0789*1.2,
    //     // borderWidth: 0.01*0.0789*1.2,
    //     // borderOpacity: 0,
    //     // borderColor: new THREE.Color( 0x7421FF ),
        
    //     // backgroundColor: new THREE.Color( 0x19764F ),
    //     // backgroundOpacity: 1,
        
    //     // fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
    //     // fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
    //     // } );
  	// 		// textMicPanel.position.set(-0.06, -0.03, 0.001);
    //     // textMicPanel.add(
    //     //   new ThreeMeshUI.Text({
    //     //     content: "Mic",
    //     //     fontSize: 0.008,
    //     //   })
    //     // );
    //     // buttonGroup.add(textMicPanel);
        
    //     // // set mic text
    //     // const transcriptText = new ThreeMeshUI.Block( {
    //     //   width: 1.9*0.07,
    //     //   height: 0.5*0.08,
    //     //   padding: 0.10*0.0789*1.2,
    //     //   justifyContent: "center",
    //     //   textAlign: "left",
    //     //   bestFit: 'grow',

    //     //   borderRadius: 0.11*0.0789*1.2,
    //     //   borderWidth: 0.01*0.0789*1.2,
    //     //   borderOpacity: 0,
    //     //   borderColor: new THREE.Color( 0x7421FF ),

    //     //   backgroundColor: new THREE.Color( 0x1E0646 ),
    //     //   backgroundOpacity: 0,

    //     //   fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
    //     //   fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
    //     // } );

    //     // transcriptText.position.set(0.028, -0.03, -0.01);
    //     // transcriptText.add(
    //     //   new ThreeMeshUI.Text({
    //     //     content: transcriptResult,
    //     //     fontSize: 0.005,
    //     //   })
    //     // );
    //     // buttonGroup.add(transcriptText);
    // }

    function clearGroup(group) {
      while(group.children.length > 0){ 
        const child = group.children[0];
        group.remove(child); 
        if(child.geometry) child.geometry.dispose();
        if(child.material) child.material.dispose();
        if(child.texture) child.texture.dispose();
      }
    }

    function tipsHaveChanged(newtips) {
        if (newtips.length !== lastTips.length) return true;
        for (let i = 0; i < newtips.length; i++) {
            if (newtips[i] !== lastTips[i]) return true;
        }
        return false;
    }

    function makeUI() {
      //uiContainer.renderOrder = 2;
      scene.add(uiContainer);

      const textPanel = new ThreeMeshUI.Block({
        width: 0.15,
        height: 0.15,
        //padding: 0.05,
        justifyContent: "center",
        textAlign: "left",
        fontFamily: "./fonts/Roboto-msdf.json",
        fontTexture: "./fonts/Roboto-msdf.png"
      });

      textPanel.position.set(0, -0.15, 0);

      uiContainer.add(textPanel);

      const title = new ThreeMeshUI.Block({
        width: 0.15,
        height: 0.05,
        justifyContent: "center",
        fontSize: 0.006,
        backgroundOpacity: 0,
      }).add(
        new ThreeMeshUI.Text({ content: "Type some text on the keyboard" })
      );
      
      for (let i = 0; i < 3; i++) {
        userTexts.push(new ThreeMeshUI.Text({ content: "The image shows a tortilla placed on a cutting board, which means you have completed step 1.\n" }));
      }
      
      const textField = new ThreeMeshUI.Block({
        width: 0.15,
        height: 0.2,
        fontSize: 0.006,
        padding: 0.012,
        backgroundOpacity: 0,
        //interLine: 0.05,
        //bestFit: 'shrink'
      })

      for (let i = 0; i < userTexts.length; i++) {
        textField.add(userTexts[i]);
      }

      textPanel.add(title, textField);
    }

    function init() {

      container = document.createElement('div');
      document.body.appendChild(container);

      // set up three.js boilerplate
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.xr.setFoveation(0);
      renderer.autoClear = false;
      container.appendChild(renderer.domElement);

      const sessionInit = {
				requiredFeatures: [ 'hand-tracking' ]
			};

      xrButton = new WebXRButton({
        onRequestSession: onRequestSession,
        onEndSession: onEndSession,
        textEnterXRTitle: "START AR",
        textXRNotFoundTitle: "AR NOT FOUND",
        textExitXRTitle: "EXIT AR",
      });

      document.querySelector('header').appendChild(xrButton.domElement);

      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar')
          .then((supported) => {
            xrButton.enabled = supported;
          });
      }

      // // add controllers to the scene
      // controller1 = renderer.xr.getController(0);
      // controller1.addEventListener('selectstart', onSelectStart);
      // controller1.addEventListener('selectend', onSelectEnd);
      // controller1.addEventListener('connected', function (event) {
      //   this.add(buildController(event.data));
      // });

      // controller1.addEventListener('disconnected', function () {
      //   this.remove(this.children[0]);
      // });

      // scene.add(controller1);

      // controller2 = renderer.xr.getController(1);
      // controller2.addEventListener('selectstart', onSelectStart);
      // controller2.addEventListener('selectend', onSelectEnd);
      // controller2.addEventListener('connected', function (event) {
      //   this.add(buildController(event.data));
      // });

      // scene.add(controller2);

      // const controllerModelFactory = new XRControllerModelFactory();

      // controllerGrip1 = renderer.xr.getControllerGrip(0);
      // controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      // scene.add(controllerGrip1);

      // controllerGrip2 = renderer.xr.getControllerGrip(1);
      // controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      // scene.add(controllerGrip2);

      // controller2.addEventListener('disconnected', function () {
      //   this.remove(this.children[0]);
      // });
      // scene.add(controller2);

      ////////////////
      // Controllers
      ////////////////

      // vrControl = VRControl( renderer, camera, scene );

      // scene.add( vrControl.controllerGrips[ 0 ], vrControl.controllers[ 0 ] );

      // vrControl.controllers[ 0 ].addEventListener( 'selectstart', () => {

      //   selectState = true;

      // } );
      // vrControl.controllers[ 0 ].addEventListener( 'selectend', () => {

      //   selectState = false;

      // } );

      // controllers
			const controller1 = renderer.xr.getController( 0 );
			scene.add( controller1 );

			const controller2 = renderer.xr.getController( 1 );
			scene.add( controller2 );

			const controllerModelFactory = new XRControllerModelFactory();

			// Hand 1
			const controllerGrip1 = renderer.xr.getControllerGrip( 0 );
			controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
			scene.add( controllerGrip1 );

			const hand1 = renderer.xr.getHand( 0 );
			const handModel1 = new OculusHandModel( hand1 );
			hand1.add( handModel1 );
      handModel1.visible = false;
			scene.add( hand1 );

			// Hand 2
			const controllerGrip2 = renderer.xr.getControllerGrip( 1 );
			controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
			scene.add( controllerGrip2 );

			const hand2 = renderer.xr.getHand( 1 );
			const handModel2 = new OculusHandModel( hand2 );
			hand2.add( handModel2 );
      handModel2.visible = false;
			scene.add( hand2 );


      // buttons

			const consoleGeometry = new THREE.BoxGeometry( 0.5, 0.12, 0.15 );
			const consoleMaterial = new THREE.MeshPhongMaterial( { color: 0x595959 } );
			const consoleMesh = new THREE.Mesh( consoleGeometry, consoleMaterial );
			consoleMesh.position.set( 0, 1, - 0.3 );
			consoleMesh.castShadow = true;
			consoleMesh.receiveShadow = true;
			scene.add( consoleMesh );
      consoleMesh.visible = false;

			const orangeButton = makeButtonMesh( 0.08*0.25*0.5, 0.1*0.25*0.5, 0.08*0.25*0.5, 0xffd3b5 );
			orangeButton.position.set(-0.06, 0, 0);
			buttonGroup.add( orangeButton );
      orangeButton.visible = false;

      const microphoneButton = makeButtonMesh( 0.08*0.25, 0.1*0.25, 0.08*0.25, 0xffd3b5 );
			microphoneButton.position.set(0, 0, 0);
			buttonGroup.add( microphoneButton );
      microphoneButton.visible = false;

			const pinkButton = makeButtonMesh( 0.08*0.25*0.5, 0.1*0.25*0.5, 0.08*0.25*0.5, 0xe84a5f );
			pinkButton.position.set(0.06, 0, 0);
			buttonGroup.add( pinkButton );
      pinkButton.visible = false;
      buttonGroup.rotation.x = Math.PI / 2;

			// const resetButton = makeButtonMesh( 0.08, 0.1, 0.08, 0x355c7d );
			// const resetButtonText = createText( 'reset', 0.03 );
			// resetButton.add( resetButtonText );
			// resetButtonText.rotation.x = - Math.PI / 2;
			// resetButtonText.position.set( 0, 0.051, 0 );
			// resetButton.position.set( 0.05, 0.04, 0 );
			// //consoleMesh.add( resetButton );
      // resetButton.visible = false;

			// const exitButton = makeButtonMesh( 0.08, 0.1, 0.08, 0xff0000 );
			// const exitButtonText = createText( 'exit', 0.03 );
			// exitButton.add( exitButtonText );
			// exitButtonText.rotation.x = - Math.PI / 2;
			// exitButtonText.position.set( 0, 0.051, 0 );
			// exitButton.position.set( 0.15, 0.04, 0 );
			// //consoleMesh.add( exitButton );
      // exitButton.visible = false;

			const tkGeometry = new THREE.TorusKnotGeometry( 0.5, 0.2, 200, 32 );
			const tkMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
			tkMaterial.metalness = 0.8;
			const torusKnot = new THREE.Mesh( tkGeometry, tkMaterial );
			torusKnot.position.set( 0, 1, - 5 );
			//scene.add( torusKnot );

			const instructionText = createText( 'This is a WebXR Hands demo, please explore with hands.', 0.04 );
			instructionText.position.set( 0, 1.6, - 0.6 );
			//scene.add( instructionText );

			const exitText = createText( 'Exiting session...', 0.04 );
			exitText.position.set( 0, 1.5, - 0.6 );
			exitText.visible = false;
			//scene.add( exitText );

			world
				.registerComponent( Object3D )
				.registerComponent( Button )
				.registerComponent( Pressable )
				.registerComponent( Rotating )
				.registerComponent( HandsInstructionText )
				.registerComponent( OffsetFromCamera )
				.registerComponent( NeedCalibration );

			world
				.registerSystem( RotatingSystem )
				.registerSystem( InstructionSystem, { controllers: [ controllerGrip1, controllerGrip2 ] } )
				.registerSystem( CalibrationSystem, { renderer: renderer, camera: camera } )
				.registerSystem( ButtonSystem, { renderer: renderer, camera: camera } )
				.registerSystem( FingerInputSystem, { hands: [ handModel1, handModel2 ] } );

			const csEntity = world.createEntity();
			csEntity.addComponent( OffsetFromCamera, { x: 0, y: - 0.4, z: - 0.3 } );
			csEntity.addComponent( NeedCalibration );
			csEntity.addComponent( Object3D, { object: consoleMesh } );

			const obEntity = world.createEntity();
			obEntity.addComponent( Pressable );
			obEntity.addComponent( Object3D, { object: orangeButton } );
			const obAction = function () {
        // this button means switch to the previous step
        const now = Date.now();
        if (now - lastCallTime < 500) return;
        lastCallTime = now;
        if (currentRecipeStep > 0) {
          currentRecipeStep--;
          shouldShowTips = false; 
          textPanelContents = [];
          setRecipe();
          // clearGroup(uiGroup); // Clear existing UI elements
          // makeTextPanel(); // Re-create text panels with updated tips
        }
			};

			obEntity.addComponent( Button, { action: obAction, surfaceY: 0.05, fullPressDistance: 0.02 } );

      const mbEntity = world.createEntity();
			mbEntity.addComponent( Pressable );
			mbEntity.addComponent( Object3D, { object: microphoneButton } );
			const mbAction = function () {
        // this button means switch to the previous step
        const now = Date.now();
        if (now - lastCallTime < 2000) return;
        lastCallTime = now;

        if (micValue == 0) {
          micValue = 1;
        } else {
          micValue = 0;
        }
			};

			mbEntity.addComponent( Button, { action: mbAction, surfaceY: 0.05, fullPressDistance: 0.02 } );

			const pbEntity = world.createEntity();
			pbEntity.addComponent( Pressable );
			pbEntity.addComponent( Object3D, { object: pinkButton } );
			const pbAction = function () {
        // this button means switch to the next step
        const now = Date.now();
        if (now - lastCallTime < 500) return;
        lastCallTime = now;
        if (currentRecipeStep < recipe.length - 1) {
          currentRecipeStep++;
          shouldShowTips = false; 
          textPanelContents = [];
          setRecipe();
          // clearGroup(uiGroup); // Clear existing UI elements
          // makeTextPanel(); // Re-create text panels with updated tips
        }

			};

			pbEntity.addComponent( Button, { action: pbAction, surfaceY: 0.05, fullPressDistance: 0.02 } );

			// const rbEntity = world.createEntity();
			// rbEntity.addComponent( Pressable );
			// rbEntity.addComponent( Object3D, { object: resetButton } );
			// const rbAction = function () {

			// 	torusKnot.material.color.setHex( 0xffffff );

			// };

			// rbEntity.addComponent( Button, { action: rbAction, surfaceY: 0.05, fullPressDistance: 0.02 } );

			// const ebEntity = world.createEntity();
			// ebEntity.addComponent( Pressable );
			// ebEntity.addComponent( Object3D, { object: exitButton } );
			// const ebAction = function () {

			// 	exitText.visible = true;
			// 	setTimeout( function () {

			// 		exitText.visible = false; renderer.xr.getSession().end();

			// 	}, 2000 );

			// };

			//ebEntity.addComponent( Button, { action: ebAction, surfaceY: 0.05, recoverySpeed: 0.2, fullPressDistance: 0.03 } );

			const tkEntity = world.createEntity();
			tkEntity.addComponent( Rotating );
			tkEntity.addComponent( Object3D, { object: torusKnot } );

			const itEntity = world.createEntity();
			itEntity.addComponent( HandsInstructionText );
			itEntity.addComponent( Object3D, { object: instructionText } );

      // const planeGeometry = new THREE.PlaneGeometry(3.22, 2.48);
      // const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
      // plane = new THREE.Mesh(planeGeometry, planeMaterial);
      // scene.add(plane);

      // ////////////////////
      // // Primitive Meshes
      // ////////////////////

      // meshContainer = new THREE.Group();
      // meshContainer.position.set( 0, 1, -1.9 );
      // scene.add( meshContainer );

      // //

      // const sphere = new THREE.Mesh(
      //   new THREE.IcosahedronBufferGeometry( 0.3, 1 ),
      //   new THREE.MeshStandardMaterial( { color: 0x3de364, flatShading: true } )
      // );

      // const box = new THREE.Mesh(
      //   new THREE.BoxBufferGeometry( 0.45, 0.45, 0.45 ),
      //   new THREE.MeshStandardMaterial( { color: 0x643de3, flatShading: true } )
      // );

      // const cone = new THREE.Mesh(
      //   new THREE.ConeBufferGeometry( 0.28, 0.5, 10 ),
      //   new THREE.MeshStandardMaterial( { color: 0xe33d4e, flatShading: true } )
      // );

      // //

      // sphere.visible = box.visible = cone.visible = false;

      // meshContainer.add( sphere, box, cone );

      // meshes = [ sphere, box, cone ];
      // currentMesh = 0;

      // showMesh( currentMesh );




      //mediapipeCanvas = document.getElementById("mediapipe-canvas");
      //ctx = mediapipeCanvas.getContext("2d", { alpha: true });
      // drawingUtils = new DrawingUtils(ctx);
      // window.drawingUtils = drawingUtils;
      
      scene.add(uiGroup);
      scene.add(buttonGroup);
      scene.add(recipeGroup);
      scene.add(micGroup);

        // uiGroup.position.copy(camera.position);
        // uiGroup.rotation.copy(camera.rotation);
        // uiGroup.translateZ(-0.5);
        // uiGroup.translateY(-0.1);
        // uiGroup.translateX(-0.1);
        // //rotate the uiGroup in the y axis 30 degrees
        // uiGroup.rotateY(20 * Math.PI / 180);
        // uiGroup.rotateX(-10 * Math.PI / 180);

        // buttonGroup.position.copy(camera.position);
        // buttonGroup.rotation.copy(camera.rotation);
        // buttonGroup.translateZ(-0.5);
        // buttonGroup.translateY(-0.1);
        // buttonGroup.translateX(-0.1);
        // //rotate the uiGroup in the y axis 30 degrees
        // buttonGroup.rotateY(20 * Math.PI / 180);
        // buttonGroup.rotateX(-10 * Math.PI / 180);

        // recipeGroup.position.copy(camera.position);
        // recipeGroup.rotation.copy(camera.rotation);
        // recipeGroup.translateZ(-0.5);
        // recipeGroup.translateY(-0.1);
        // recipeGroup.translateX(-0.1);
        // //rotate the uiGroup in the y axis 30 degrees
        // recipeGroup.rotateY(20 * Math.PI / 180);
        // recipeGroup.rotateX(-10 * Math.PI / 180);

        // micGroup.position.copy(camera.position);
        // micGroup.rotation.copy(camera.rotation);
        // micGroup.translateZ(-0.5);
        // micGroup.translateY(-0.1);
        // micGroup.translateX(-0.1);
        // //rotate the uiGroup in the y axis 30 degrees
        // micGroup.rotateY(20 * Math.PI / 180);
        // micGroup.rotateX(-10 * Math.PI / 180);
      //makeUI();
      // Update UI with new tips
      clearGroup(uiGroup); // Clear existing UI elements
      makeTextPanel();
      setRecipe();
      //setMicandTranscript();
      //makePanel();

      setInterval(sendStepIfChanged, 500);

      setInterval(sendMicValueIfChanged, 500);
      
      //setInterval(sendTranscriptIfChanged, 500);

      updateState();

      window.addEventListener('resize', onWindowResize);
    }

    function buildController(data) {

      let geometry, material;

      switch (data.targetRayMode) {
        case 'tracked-pointer':
          geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
          geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));

          material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

          return new THREE.Line(geometry, material);
        case 'gaze':
          geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
          material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
          return new THREE.Mesh(geometry, material);
      }
    }

    let pointer = undefined;

    function onSelectStart(event) {
      selectState = true;
      pointer = event.target;
    }
    function onSelectEnd(event) {
      selectState = false;
      pointer = undefined;
    }

    // function draw() { // the original raycasting function
    //   if (pointer === undefined) {
    //     return;
    //   }


    //   let yOffset = 0; 
    //   textPlanes.forEach(textPlane => {
    //     scene.remove(textPlane);
    //     if (textPlane.geometry) textPlane.geometry.dispose();
    //     if (textPlane.material) textPlane.material.dispose();
    //   });
    //   textPlanes = [];

          
    //   // Process tips in reverse order to have the last one as the baseline
    //   jsonData.tipsHistory.slice().reverse().forEach((tip, index) => {
    //     const name = tip.tip;
    //     let a = 0; // 'a' remains constant to keep tips aligned vertically
    //     let b = 0; // 'b' is constant because we're manually adjusting the vertical offset

    //     const textPlane = createText(name, 0.0125);
    //     textPlane.matrixAutoUpdate = true;
    //     textPlane.visible = false;
    //     scene.add(textPlane);
    //     const raycaster = new THREE.Raycaster();

    //     raycaster.setFromCamera(new THREE.Vector2(a, b), camera);

    //     allMeshes.forEach((meshContext, mesh) => {
    //       const intersections = raycaster.intersectObject(meshContext.mesh);

    //       if (intersections.length > 0) {
    //         textPlane.visible = true;
    //         // Position the baseline tip, then adjust yOffset upwards for each subsequent tip
    //         textPlane.position.copy(intersections[0].point).add(new THREE.Vector3(0, yOffset, 0));
    //         textPlane.material.depthTest = false;
    //         textPlane.material.needsUpdate = true;
    //         textPlanes.push(textPlane);

    //         // Increment yOffset to move the next tip upwards
    //         yOffset += 0.02; // Adjust this value as needed for your spacing
    //       }
    //     });
    //   });
    // }

    function onRequestSession() {
      let sessionInit = {
        requiredFeatures: ['hit-test', 'mesh-detection', 'hand-tracking'],
        optionalFeatures: [],
      };
      if (useDomOverlay.checked) {
        sessionInit.optionalFeatures.push('dom-overlay');
        sessionInit.domOverlay = { root: document.body };
      }
      navigator.xr.requestSession('immersive-ar', sessionInit).then((session) => {
        session.mode = 'immersive-ar';
        xrButton.setSession(session);
        onSessionStarted(session);
      });
    }

    function onSessionStarted(session) {
      useDomOverlay.disabled = true;
      session.addEventListener('end', onSessionEnded);

      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);

      renderer.setAnimationLoop(render);
    }

    function onEndSession(session) {
      session.end();
    }

    function onSessionEnded(event) {
      useDomOverlay.disabled = false;
      xrButton.setSession(null);

      renderer.setAnimationLoop(null);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 32).translate(0, 0.1, 0);

    function createGeometry(vertices, indices) {
      const geometry = new THREE.BufferGeometry();
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

      return geometry;
    }

    let meshId = 1;
    let allMeshes = new Map();
    // Iterate over the meshes array and compare to our internal state
    // This is the code that keeps track of the mesh state and adds them to the scene.
    function processMeshes(timestamp, frame) {
      const referenceSpace = renderer.xr.getReferenceSpace();

      if (frame.detectedMeshes) {
        allMeshes.forEach((meshContext, mesh) => {
          // if a previous mesh is no longer reported
          if (!frame.detectedMeshes.has(mesh)) {
            // mesh was removed
            allMeshes.delete(mesh);
            console.debug("Mesh no longer tracked, id=" + meshContext.id);

            scene.remove(meshContext.mesh);
            scene.remove(meshContext.wireframe);
          }
        });

        // compare all incoming meshes with our internal state
        frame.detectedMeshes.forEach(mesh => {
          const meshPose = frame.getPose(mesh.meshSpace, referenceSpace);
          let meshMesh;
          let wireframeMesh;

          // this is a mesh we've seen before
          if (allMeshes.has(mesh)) {
            // may have been updated:
            const meshContext = allMeshes.get(mesh);
            meshMesh = meshContext.mesh;
            wireframeMesh = meshContext.wireframe;

            if (meshContext.timestamp < mesh.lastChangedTime) {
              // the mesh was updated!
              meshContext.timestamp = mesh.lastChangedTime;

              const geometry = createGeometry(mesh.vertices, mesh.indices);
              meshContext.mesh.geometry.dispose();
              meshContext.mesh.geometry = geometry;
              meshContext.wireframe.geometry.dispose();
              meshContext.wireframe.geometry = geometry;
            }
          } else {
            // new mesh

            // Create geometry:
            const geometry = createGeometry(mesh.vertices, mesh.indices);

            //wireframeMaterial.depthTest = true;
            wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
            wireframeMesh.matrixAutoUpdate = false;
            scene.add(wireframeMesh);

            meshMesh = new THREE.Mesh(geometry,
              meshMaterials[meshId % meshMaterials.length]
            );
            //meshMesh.material.depthTest = true;
            meshMesh.matrixAutoUpdate = false;
            scene.add(meshMesh);
            const originGroup = baseOriginGroup.clone();
            originGroup.visible = false;

            meshMesh.add(originGroup);
            allMeshOrigins.push(originGroup);

            const meshContext = {
              id: meshId,
              timestamp: mesh.lastChangedTime,
              mesh: meshMesh,
              wireframe: wireframeMesh,
              origin: originGroup,
            };

            allMeshes.set(mesh, meshContext);
            console.debug("New mesh detected, id=" + meshId);
            meshId++;
          }

          if (meshPose) {
            meshMesh.visible = true;
            meshMesh.matrix.fromArray(meshPose.transform.matrix);
            wireframeMesh.visible = showMeshTriangles.checked;
            wireframeMesh.matrix.fromArray(meshPose.transform.matrix);
          } else {
            meshMesh.visible = false;
            wireframeMesh.visible = false;
          }
        });
      }
    }

    // function showMesh( id ) {
    //   meshes.forEach( ( mesh, i ) => {
    //     mesh.visible = i === id ? true : false;
    //   } );
    // }

    function makePanel() {
      // Create a panel with two buttons to switch between the three meshes
      // Container block, in which we put the two buttons.
      // We don't define width and height, it will be set automatically from the children's dimensions
      // Note that we set contentDirection: "row-reverse", in order to orient the buttons horizontally

      const container = new ThreeMeshUI.Block( {
        justifyContent: 'center',
        contentDirection: 'row-reverse',
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
        fontSize: 0.07,
        padding: 0.02,
        borderRadius: 0.11
      } );

      container.position.set( 0, 0.6, -1.2 );
      container.rotation.x = -0.55;
      scene.add( container );

      // BUTTONS

      // We start by creating objects containing options that we will use with the two buttons,
      // in order to write less code.

      const buttonOptions = {
        width: 0.4,
        height: 0.15,
        justifyContent: 'center',
        offset: 0.05,
        margin: 0.02,
        borderRadius: 0.075
      };

      // Options for component.setupState().
      // It must contain a 'state' parameter, which you will refer to with component.setState( 'name-of-the-state' ).

      const hoveredStateAttributes = {
        state: 'hovered',
        attributes: {
          offset: 0.035,
          backgroundColor: new THREE.Color( 0x999999 ),
          backgroundOpacity: 1,
          fontColor: new THREE.Color( 0xffffff )
        },
      };

      const idleStateAttributes = {
        state: 'idle',
        attributes: {
          offset: 0.035,
          backgroundColor: new THREE.Color( 0x666666 ),
          backgroundOpacity: 0.3,
          fontColor: new THREE.Color( 0xffffff )
        },
      };

      // Buttons creation, with the options objects passed in parameters.

      const buttonNext = new ThreeMeshUI.Block( buttonOptions );
      const buttonPrevious = new ThreeMeshUI.Block( buttonOptions );

      // Add text to buttons

      buttonNext.add(
        new ThreeMeshUI.Text( { content: 'next' } )
      );

      buttonPrevious.add(
        new ThreeMeshUI.Text( { content: 'previous' } )
      );

      // Create states for the buttons.
      // In the loop, we will call component.setState( 'state-name' ) when mouse hover or click

      const selectedAttributes = {
        offset: 0.02,
        backgroundColor: new THREE.Color( 0x777777 ),
        fontColor: new THREE.Color( 0x222222 )
      };

      buttonNext.setupState( {
        state: 'selected',
        attributes: selectedAttributes,
        onSet: () => {

          currentMesh = ( currentMesh + 1 ) % 3;
          showMesh( currentMesh );

        }
      } );
      buttonNext.setupState( hoveredStateAttributes );
      buttonNext.setupState( idleStateAttributes );

      //

      buttonPrevious.setupState( {
        state: 'selected',
        attributes: selectedAttributes,
        onSet: () => {

          currentMesh -= 1;
          if ( currentMesh < 0 ) currentMesh = 2;
          showMesh( currentMesh );

        }
      } );
      buttonPrevious.setupState( hoveredStateAttributes );
      buttonPrevious.setupState( idleStateAttributes );

      //

      container.add( buttonNext, buttonPrevious );
      objsToTest.push( buttonNext, buttonPrevious );

    }

    // function updateButtons() {
    //   // Find closest intersecting object

    //   let intersect;

    //   if (renderer.xr.isPresenting) {
    //     vrControl.setFromController(0, raycaster.ray);

    //     intersect = raycast();

    //     // Position the little white dot at the end of the controller pointing ray
    //     if (intersect) vrControl.setPointerAt(0, intersect.point);
    //   } else if (mouse.x !== null && mouse.y !== null) {
    //     raycaster.setFromCamera(mouse, camera);

    //     intersect = raycast();
    //   }

    //   // Update targeted button state (if any)

    //   if (intersect && intersect.object.isUI) {
    //     if (selectState) {
    //       // Component.setState internally call component.set with the options you defined in component.setupState
    //       intersect.object.setState("selected");
    //     } else {
    //       // Component.setState internally call component.set with the options you defined in component.setupState
    //       intersect.object.setState("hovered");
    //     }
    //   }

    //   // Update non-targeted buttons state

    //   objsToTest.forEach((obj) => {
    //     if ((!intersect || obj !== intersect.object) && obj.isUI) {
    //       // Component.setState internally call component.set with the options you defined in component.setupState
    //       obj.setState("idle");
    //     }
    //   });
    // }

    //

    function raycast() {
      return objsToTest.reduce((closestIntersection, obj) => {
        const intersection = raycaster.intersectObject(obj, true);

        if (!intersection[0]) return closestIntersection;

        if (
          !closestIntersection ||
          intersection[0].distance < closestIntersection.distance
        ) {
          intersection[0].object = obj;

          return intersection[0];
        }

        return closestIntersection;
      }, null);
    }

    
    function render(timestamp, frame) {
      if (frame) {
        processMeshes(timestamp, frame);
        //draw();

        // // Update text planes to face the camera but keep them horizontally level
        // textPlanes.forEach(textPlane => {
        //   // Copy the camera's position to a temporary vector
        //   let tempPosition = new THREE.Vector3();
        //   camera.getWorldPosition(tempPosition);

        //   // Ignore the Y component of the camera and text plane positions for the lookAt calculation
        //   //tempPosition.y = textPlane.position.y;

        //   // Make the text plane face towards the camera's XZ projection
        //   textPlane.lookAt(tempPosition);
        // });

        let basePosition = camera.position.clone();
        let baseRotation = camera.rotation.clone();

        let translateZ = -0.35; // The most common Z translation
        let translateY = -0.27; // The most common Y translation
        let rotateX = -30 * Math.PI / 180;

        [uiGroup, buttonGroup, recipeGroup].forEach(group => {
          group.position.copy(basePosition);
          group.rotation.copy(baseRotation);
          group.translateZ(translateZ);
          group.translateY(group === buttonGroup ? 0.1 : translateY);
          group.rotateX(group === buttonGroup ? 30 * Math.PI / 180 : rotateX);
        });

        // uiGroup.position.copy(camera.position);
        // uiGroup.rotation.copy(camera.rotation);
        // uiGroup.translateZ(-0.35);
        // uiGroup.translateY(-0.27);
        // //uiGroup.translateX(-0.1);
        // //uiGroup.rotateY(10 * Math.PI / 180);
        // uiGroup.rotateX(-30 * Math.PI / 180);

        // buttonGroup.position.copy(camera.position);
        // buttonGroup.rotation.copy(camera.rotation);
        // buttonGroup.translateZ(-0.3);
        // buttonGroup.translateY(-0.23);
        // //buttonGroup.translateX(-0.1);
        // //buttonGroup.rotateY(10 * Math.PI / 180);
        // buttonGroup.rotateX(-30 * Math.PI / 180);

        // recipeGroup.position.copy(camera.position);
        // recipeGroup.rotation.copy(camera.rotation);
        // recipeGroup.translateZ(-0.35);
        // recipeGroup.translateY(-0.27);
        // //recipeGroup.translateX(-0.1);
        // //recipeGroup.rotateY(10 * Math.PI / 180);
        // recipeGroup.rotateX(-30 * Math.PI / 180);

        // micGroup.position.copy(camera.position);
        // micGroup.rotation.copy(camera.rotation);
        // micGroup.translateZ(-0.5);
        // micGroup.translateY(-0.1);
        // micGroup.translateX(-0.1);
        // //rotate the uiGroup in the y axis 30 degrees
        // micGroup.rotateY(20 * Math.PI / 180);
        // micGroup.rotateX(-10 * Math.PI / 180);


        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();
        
        // if (plane && camera) {
        //   plane.position.copy(camera.position);
        //   plane.rotation.copy(camera.rotation);

        //   plane.translateZ(-2);
        // }

        // plane.visible = false;

        ThreeMeshUI.update();
        
        const delta = clock.getDelta();
        const elapsedTime = clock.elapsedTime;
        renderer.xr.updateCamera( camera );
        world.execute( delta, elapsedTime );
        renderer.render(scene, camera);

        //updateButtons();
      }
    }

  </script>
</body>

</html>