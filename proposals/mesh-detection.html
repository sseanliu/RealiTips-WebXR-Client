<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>

  <meta http-equiv="origin-trial"
    content="Ahfj+MLeL6bh+LNmpnSdepftxoDHHwjUG2KWZ4jjCb1WoZxtBlzF3cDHuJNVqnhr3HXJwQ+kLaw57NO15S0mRwwAAABkeyJvcmlnaW4iOiJodHRwczovL2ltbWVyc2l2ZS13ZWIuZ2l0aHViLmlvOjQ0MyIsImZlYXR1cmUiOiJXZWJYUlBsYW5lRGV0ZWN0aW9uIiwiZXhwaXJ5IjoxNjI5ODQ5NTk5fQ==">

  <title>AR Mesh Detection</title>

  <link href='../css/common.css' rel='stylesheet'>
  </link>
  <script
    type="modele"
    src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"
    crossorigin="anonymous"
  ></script>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1/dist/peerjs.min.js"></script>

</head>

<body>
  <canvas id="mediapipe-canvas"></canvas>
  <video id="segmentVideo" autoplay muted style="display: none;"></video>
  <header>
    <details open>
      <summary>AR Mesh Detection</summary>
      This sample demonstrates using the
      <a href="https://immersive-web.github.io/real-world-meshing/">>Mesh Detection feature</a>
      including an implementation of synchronous hit test in JavaScript
      that leverages obtained mesh data to position objects.
      <p>
        <input id="showMeshTriangles" type="checkbox" checked>
        <label for="showMeshTriangles">Mesh triangles visible</label><br />

        <input id="useDomOverlay" type="checkbox" checked>
        <label for="useDomOverlay">Enable DOM Overlay</label><br />

        <a class="back" href="./index.html">Back</a>
      </p>
    </details>
  </header>
  <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>
  <script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
          "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/",
          "three-mesh-ui": "https://unpkg.com/three-mesh-ui@6.5.4/build/three-mesh-ui.module.js"
				}
			}
		</script>

  <script type="module">
    // Code adapted from THREE.js' WebXR hit test sample.
    // THREE.js is covered by MIT license which can be found at:
    // https://github.com/mrdoob/THREE.js/blob/master/LICENSE

    // The code also links to a .png file from ARCore Android SDK.
    // It is covered by Apache 2.0 license which can be found at:
    // https://github.com/google-ar/arcore-android-sdk/blob/c684bbda37e44099c273c3e5274fae6fccee293c/LICENSE

    import * as THREE from 'three';
    import * as ThreeMeshUI from "three-mesh-ui";
    //import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
    import { BoxLineGeometry } from 'three/examples/jsm/geometries/BoxLineGeometry.js';
    //import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    //import VRControl from './utils/VRControl.js';
    import { XRControllerModelFactory } from 'three/examples/jsm/webxr/XRControllerModelFactory.min.js';
    import {createText} from 'three/examples/jsm/webxr/Text2D.js';
    import { OculusHandModel } from 'three/examples/jsm/webxr/OculusHandModel.js';
    import { WebXRButton } from '../js/util/webxr-button.js';
    import { hitTest, filterHitTestResults } from '../js/hit-test.js';
    import {
      PoseLandmarker,
      FaceLandmarker,
      DrawingUtils,
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision";
    import { World, System, Component, TagComponent, Types } from 'three/examples/jsm/libs/ecsy.module.js';

    class Object3D extends Component { }

		Object3D.schema = {
			object: { type: Types.Ref }
		};

		class Button extends Component { }

		Button.schema = {
			// button states: [resting, pressed, fully_pressed, recovering]
			currState: { type: Types.String, default: 'resting' },
			prevState: { type: Types.String, default: 'resting' },
			pressSound: { type: Types.Ref, default: null },
			releaseSound: { type: Types.Ref, default: null },
			restingY: { type: Types.Number, default: null },
			surfaceY: { type: Types.Number, default: null },
			recoverySpeed: { type: Types.Number, default: 0.4 },
			fullPressDistance: { type: Types.Number, default: null },
			action: { type: Types.Ref, default: () => { } }
		};

		class ButtonSystem extends System {

			init( attributes ) {

				this.renderer = attributes.renderer;
				this.soundAdded = false;

			}

			execute( /*delta, time*/ ) {

				let buttonPressSound, buttonReleaseSound;
				if ( this.renderer.xr.getSession() && ! this.soundAdded ) {

					const xrCamera = this.renderer.xr.getCamera();

					const listener = new THREE.AudioListener();
					xrCamera.add( listener );

					// create a global audio source
					buttonPressSound = new THREE.Audio( listener );
					buttonReleaseSound = new THREE.Audio( listener );

					// load a sound and set it as the Audio object's buffer
					const audioLoader = new THREE.AudioLoader();
					audioLoader.load( './webxr-hands-examples-main/sounds/button-press.ogg', function ( buffer ) {

						buttonPressSound.setBuffer( buffer );

					} );
					audioLoader.load( './webxr-hands-examples-main/sounds/button-release.ogg', function ( buffer ) {

						buttonReleaseSound.setBuffer( buffer );

					} );
					this.soundAdded = true;

				}

				this.queries.buttons.results.forEach( entity => {

					const button = entity.getMutableComponent( Button );
					const buttonMesh = entity.getComponent( Object3D ).object;
					// populate restingY
					if ( button.restingY == null ) {

						button.restingY = buttonMesh.position.y;

					}

					if ( buttonPressSound ) {

						button.pressSound = buttonPressSound;

					}

					if ( buttonReleaseSound ) {

						button.releaseSound = buttonReleaseSound;

					}

					if ( button.currState == 'fully_pressed' && button.prevState != 'fully_pressed' ) {

						if ( button.pressSound ) button.pressSound.play();
						button.action();

					}

					if ( button.currState == 'recovering' && button.prevState != 'recovering' ) {

						if ( button.releaseSound ) button.releaseSound.play();

					}

					// preserve prevState, clear currState
					// FingerInputSystem will update currState
					button.prevState = button.currState;
					button.currState = 'resting';

				} );

			}

		}

		ButtonSystem.queries = {
			buttons: {
				components: [ Button ]
			}
		};

		class Pressable extends TagComponent { }

		class FingerInputSystem extends System {

			init( attributes ) {

				this.hands = attributes.hands;

			}

			execute( delta/*, time*/ ) {

				this.queries.pressable.results.forEach( entity => {

					const button = entity.getMutableComponent( Button );
					const object = entity.getComponent( Object3D ).object;
					const pressingDistances = [];
					this.hands.forEach( hand => {

						if ( hand && hand.intersectBoxObject( object ) ) {

							const pressingPosition = hand.getPointerPosition();
							pressingDistances.push( button.surfaceY - object.worldToLocal( pressingPosition ).y );

						}

					} );
					if ( pressingDistances.length == 0 ) { // not pressed this frame

						if ( object.position.y < button.restingY ) {

							object.position.y += button.recoverySpeed * delta;
							button.currState = 'recovering';

						} else {

							object.position.y = button.restingY;
							button.currState = 'resting';

						}

					} else {

						button.currState = 'pressed';
						const pressingDistance = Math.max( pressingDistances );
						if ( pressingDistance > 0 ) {

							object.position.y -= pressingDistance;

						}

						if ( object.position.y <= button.restingY - button.fullPressDistance ) {

							button.currState = 'fully_pressed';
							object.position.y = button.restingY - button.fullPressDistance;

						}

					}

				} );

			}

		}

		FingerInputSystem.queries = {
			pressable: {
				components: [ Pressable ]
			}
		};

		class Rotating extends TagComponent { }

		class RotatingSystem extends System {

			execute( delta/*, time*/ ) {

				this.queries.rotatingObjects.results.forEach( entity => {

					const object = entity.getComponent( Object3D ).object;
					object.rotation.x += 0.4 * delta;
					object.rotation.y += 0.4 * delta;

				} );

			}

		}

		RotatingSystem.queries = {
			rotatingObjects: {
				components: [ Rotating ]
			}
		};

		class HandsInstructionText extends TagComponent { }

		class InstructionSystem extends System {

			init( attributes ) {

				this.controllers = attributes.controllers;

			}

			execute( /*delta, time*/ ) {

				let visible = false;
				this.controllers.forEach( controller => {

					if ( controller.visible ) {

						visible = true;

					}

				} );

				this.queries.instructionTexts.results.forEach( entity => {

					const object = entity.getComponent( Object3D ).object;
					object.visible = visible;

				} );

			}

		}

		InstructionSystem.queries = {
			instructionTexts: {
				components: [ HandsInstructionText ]
			}
		};

		class OffsetFromCamera extends Component { }

		OffsetFromCamera.schema = {
			x: { type: Types.Number, default: 0 },
			y: { type: Types.Number, default: 0 },
			z: { type: Types.Number, default: 0 },
		};

		class NeedCalibration extends TagComponent { }

		class CalibrationSystem extends System {

			init( attributes ) {

				this.camera = attributes.camera;
				this.renderer = attributes.renderer;

			}

			execute( /*delta, time*/ ) {

				this.queries.needCalibration.results.forEach( entity => {

					if ( this.renderer.xr.getSession() ) {

						const offset = entity.getComponent( OffsetFromCamera );
						const object = entity.getComponent( Object3D ).object;
						const xrCamera = this.renderer.xr.getCamera();
						object.position.x = xrCamera.position.x + offset.x;
						object.position.y = xrCamera.position.y + offset.y;
						object.position.z = xrCamera.position.z + offset.z;
						entity.removeComponent( NeedCalibration );

					}

				} );

			}

		}

		CalibrationSystem.queries = {
			needCalibration: {
				components: [ NeedCalibration ]
			}
		};

    const world = new World();
		const clock = new THREE.Clock();

    const showMeshTriangles = document.getElementById('showMeshTriangles');

    const allMeshOrigins = [];

    function updateState() {
      const createMeshMaterial = (params) =>
        new THREE.MeshBasicMaterial(Object.assign(params, {
          opacity: 0.15,
          transparent: true,
          //depthTest: true
        }));

      meshMaterials.splice(0, meshMaterials.length)
      if (showMeshTriangles.checked) {
        // preallocate colors for various meshes  
        meshMaterials.push(createMeshMaterial({ color: 0xff0000 }));
        meshMaterials.push(createMeshMaterial({ color: 0x00ff00 }));
        meshMaterials.push(createMeshMaterial({ color: 0x0000ff }));
        meshMaterials.push(createMeshMaterial({ color: 0xffff00 }));
        meshMaterials.push(createMeshMaterial({ color: 0x00ffff }));
        meshMaterials.push(createMeshMaterial({ color: 0xff00ff }));
      } else {
        // if the mesh is not visible, set the blending so the mesh "punches"
        // out vr content behind it. This will occlude the VR scene with the 
        // real world.
        let material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.FrontSide });
        material.blending = THREE.CustomBlending;
        material.blendEquation = THREE.AddEquation;
        material.blendSrc = THREE.ZeroFactor;
        material.blendDst = THREE.ZeroFactor;
        material.depthWrite = false;
        //material.depthTest = true;
        meshMaterials.push(material);
      }
    }

    showMeshTriangles.addEventListener('input', element => updateState());

    // Suppress XR events for interactions with the DOM overlay
    document.querySelector('header').addEventListener('beforexrselect', (ev) => {
      console.log(ev.type);
      ev.preventDefault();
    });

    let xrButton = null;
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;

    let container;
    //let camera, scene, renderer, vrControl;
    let camera, scene, renderer;
    let meshContainer, meshes, currentMesh;
    const objsToTest = [];
    let selectState = false;
    const raycaster = new THREE.Raycaster();

    const tempMatrix = new THREE.Matrix4();

    // let reticle;
    // hitResult will be set when reticle is visible:
    let hitResult;

    let plane;

    let mediapipeCanvas;
    let ctx;
    let video;
    let drawingUtils;

    const peer = new Peer();
    let conn;
    let jsonData;
    let videoWidth;
    let videoHeight;
    let textPlanes = [];

    // UI
    //
    const uiContainer = new THREE.Group();
    let userTexts = [];
    let userText1;
    let userText2;
    let userText3;
    const uiGroup = new THREE.Group();
    const buttonGroup = new THREE.Group();
    uiGroup.renderOrder = 2;
    buttonGroup.renderOrder = 2;
    let currentYOffset = 0;
    let textPanelContents = [];

    // for Testing:
    // textPanelContents[0] = "1. The image shows a tortilla placed on a cutting board.";
    // //push
    // textPanelContents.push("2. The image shows a jar of nut butter.");

    function setupPeerConnection(){
      peer.on("open", (id) => {
        console.log(id);
        conn = peer.connect("4d7a1");
        conn.on("open", () => {
          console.log("Start receiving data");
          conn.on("data", (data) => {
            try {
              // console.log("receiving data");
              jsonData = JSON.parse(data);
              window.jsonData = jsonData;
              //drawData(jsonData);
              //console.log(jsonData);
              videoWidth = jsonData.streamWidth;
              videoHeight = jsonData.streamHeight;

              const newHints = jsonData.hintsHistory.map(hint => hint.hint);
              if (hintsHaveChanged(newHints)) {
                  // Only reset and repopulate textPanelContents if the hints have changed
                  textPanelContents = []; // Reset the contents
                  jsonData.hintsHistory.forEach(hint => {
                    textPanelContents.push(hint.hint);
                  });

                  clearGroup(uiGroup); // Clear existing UI elements
                  makeTextPanel(); // Re-create text panels with updated hints
              }
              
            } catch (e) {
              console.error("Error parsing received JSON:", e);
            }
          });
        });

        peer.on("call", (call) => {
          call.answer();
          call.on("stream", (stream) => {
            console.log("stream");
            video = document.getElementById("segmentVideo");
            video.srcObject = stream;
            video.play();
          });
        });
      });
    }

    // // 绘制数据
    // function drawData(result) {
    //     ctx.clearRect(0, 0, mediapipeCanvas.width, mediapipeCanvas.height);
    //     if (result.objectDetector) drawObject(result);
    //     updatePlaneMaterial(mediapipeCanvas); // 更新 Three.js 平面的材质
        
    //     // Assuming hints are in result.hintsHistory
    //     let startY = 20; // Start 20 pixels from the top of the canvas
    //     const hintHeight = 20; // Assuming each hint needs 20 pixels of height
    //     for (let hint of result.hintsHistory) {
    //         // Draw the hint text at the current Y position
    //         ctx.fillStyle = "#000000";
    //         ctx.font = "12px Arial";
    //         ctx.fillText(hint.hint, 10, startY); // Draw hint at x=10, y=startY
            
    //         startY += hintHeight; // Move startY down for the next hint
    //     }
    // }

    // 更新 Three.js 平面的材质
    function updatePlaneMaterial(textureCanvas) {
        const texture = new THREE.CanvasTexture(textureCanvas);
        texture.needsUpdate = true;
        plane.material.map = texture;
        plane.material.needsUpdate = true;
    }

    // 处理 MediaPipe 检测到的对象
    //-----the same------
    // function drawObject(result) {
    //   for (let detection of result.objectDetector.detections) {
    //     const name = detection.categories[0].categoryName;
    //     const score = Math.round(
    //       parseFloat(detection.categories[0].score) * 100
    //     );
    //     const bbox = detection.boundingBox;
    //     let x = bbox.originX;
    //     let y = bbox.originY;
    //     let width = bbox.width;
    //     let height = bbox.height;
    //     let centerX = x + width / 2;
    //     let centerY = y + height / 2;
    //     //console.log(name, score, x, y, width, height);

    //     ctx.strokeStyle = "#fff";
    //     ctx.fillStyle = "rgba(255, 255, 0, 0.25)";
    //     ctx.lineWidth = 1;
    //     ctx.fillRect(x, y, width, height);
    //     ctx.strokeRect(x, y, width, height);

    //     ctx.fillRect(centerX - 2, centerY - 2, 4, 4);
    //     ctx.strokeRect(centerX - 2, centerY - 2, 4, 4);

    //     ctx.fillStyle = "#007f8b";
    //     ctx.font = "12px Arial";
    //     ctx.fillText(`${name} - ${score}%`, x, y - 10);
    //   }

    //   for (let hint of result.hintsHistory) {
    //     ctx.fillStyle = "#000000";
    //     ctx.font = "12px Arial";
    //     // make the hint at the center of screen
    //     ctx.fillText(hint.hint, mediapipeCanvas.width / 2, mediapipeCanvas.height / 2);
    //     // console.log(hint.hint, hint.row, hint.column);
    //     console.log(hint.hint);
    //   }
    // }

    const meshMaterials = [];
    const wireframeMaterial = new THREE.MeshBasicMaterial({ wireframe: true });
    const baseOriginGroup = new THREE.Group();

    init();
    setupPeerConnection();

    function makeButtonMesh( x, y, z, color ) {

      const geometry = new THREE.BoxGeometry( x, y, z );
      const material = new THREE.MeshPhongMaterial( { color: color } );
      const buttonMesh = new THREE.Mesh( geometry, material );
      buttonMesh.castShadow = true;
      buttonMesh.receiveShadow = true;
      return buttonMesh;

    }

    function setTextPanel(textPanelContent){

      // set background
      const conBlank = new ThreeMeshUI.Block( {
        justifyContent: 'start',  
        contentDirection: 'column',
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
        fontSize: 0.07*0.0789*1.2,
        //bestFit: 'auto',
        padding: 0.10*0.0789*1.2,
        borderWidth: 0.01*0.0789*1.2,
        borderOpacity: 1,
          borderColor: new THREE.Color( 0x0D87E0 ),
        backgroundColor: new THREE.Color( 0x1E0646 ),
        backgroundOpacity: 0.75,
        borderRadius: 0.11*0.0789*1.2,
        width: 1.9*0.0789*1.2,
        height: 0.5*0.05*2*0.8,
      } );
      conBlank.position.set(0, -0.03 + currentYOffset, 0);
      uiGroup.add(conBlank);

      // set text
      const conText = new ThreeMeshUI.Block( {
      width: 1.9*0.0789*1.2,
      height: 0.5*0.0789*1.2,
      padding: 0.10*0.0789*1.2,
      justifyContent: "center",
      textAlign: "left",
      bestFit: 'grow',

      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      borderColor: new THREE.Color( 0x0D87E0 ),

      backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 0,

      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );

      conText.position.set(0, -0.03 + currentYOffset, -0.01);
      conText.add(
      new ThreeMeshUI.Text({
        content: textPanelContent,
        fontSize: 0.05*0.2*0.8,
      })
      );
      uiGroup.add(conText);

      currentYOffset -= 0.048;
    }

    function makeTextPanel() {
      currentYOffset = 0; // Reset the offset for each update

      // set background
      const containerBlank = new ThreeMeshUI.Block( {
        justifyContent: 'start',  
        contentDirection: 'column',
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
        fontSize: 0.07*0.0789*1.2,
        //bestFit: 'auto',
        padding: 0.10*0.0789*1.2,
        borderWidth: 0.01*0.0789*1.2,
        borderOpacity: 1,
          borderColor: new THREE.Color( 0x0D87E0 ),
        backgroundColor: new THREE.Color( 0x1E0646 ),
        backgroundOpacity: 0.75,
        borderRadius: 0.11*0.0789*1.2,
        width: 1.9*0.0789*1.2,
        height: 0.5*0.05*4*1.2,
      } );
      containerBlank.position.set(0, 0.25*0.0789*5-0.03, 0);
      uiGroup.add(containerBlank);

      // set text
      const containerText = new ThreeMeshUI.Block( {
        width: 1.9*0.0789*1.2,
      height: 0.5*0.0789*1.2,
      padding: 0.10*0.0789*1.2,
      justifyContent: "center",
      textAlign: "left",
      bestFit: 'grow',

      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      borderColor: new THREE.Color( 0x0D87E0 ),

      backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 0,

      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );
      containerText.position.set(0, 0.35*0.0789*2.7+0.04-0.03, -0.01);
      containerText.add(
        new ThreeMeshUI.Text({
          content: "Step 2: Use a butter knife to scoop nut butter from the jar. Spread nut butter onto tortilla, leaving 1/2-inch uncovered at the edges.",
          fontSize: 0.05*0.0789*2,
        })
      );
      uiGroup.add(containerText);

      // set text Panel
      const textPreviousPanel = new ThreeMeshUI.Block( {
        width: 0.05,
      height: 0.025,
      padding: 0,
      justifyContent: "center",
      textAlign: "center",
      bestFit: 'auto',
      
      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      borderColor: new THREE.Color( 0x7421FF ),
      
      backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 1,
      
      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );
      textPreviousPanel.position.set(-0.06, 0.35*0.0789*2.7+0.04-0.1+0.01, 0.001);
      textPreviousPanel.add(
        new ThreeMeshUI.Text({
          content: "Previous",
          fontSize: 0.008,
        })
      );
      uiGroup.add(textPreviousPanel);
      
              
      // set text Panel
      const textNextPanel = new ThreeMeshUI.Block( {
        width: 0.05,
      height: 0.025,
      padding: 0,
      justifyContent: "center",
      textAlign: "center",
      bestFit: 'auto',
      
      borderRadius: 0.11*0.0789*1.2,
      borderWidth: 0.01*0.0789*1.2,
      borderOpacity: 0,
      borderColor: new THREE.Color( 0x7421FF ),
      
      backgroundColor: new THREE.Color( 0x1E0646 ),
      backgroundOpacity: 1,
      
      fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
      fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png'
      } );
      textNextPanel.position.set(0.06, 0.35*0.0789*2.7+0.04-0.1+0.01, -0.005);
      textNextPanel.add(
        new ThreeMeshUI.Text({
          content: "Next",
          fontSize: 0.008,
        })
      );
      uiGroup.add(textNextPanel);

      // for (let i=0; i<textPanelContents.length; i++){
      // setTextPanel(textPanelContents[i]);
      // //set an offset on Y axis for each text panel
      // //textPanelContents[i].position.set(0, 0.5, 0);
      // }

      textPanelContents.forEach(content => {
        setTextPanel(content);
      });

    }

    function clearGroup(group) {
      while(group.children.length > 0){ 
        const child = group.children[0];
        group.remove(child); 
        if(child.geometry) child.geometry.dispose();
        if(child.material) child.material.dispose();
        if(child.texture) child.texture.dispose();
      }
    }

    function hintsHaveChanged(newHints) {
        if (newHints.length !== textPanelContents.length) return true;
        for (let i = 0; i < newHints.length; i++) {
            if (newHints[i] !== textPanelContents[i]) return true;
        }
        return false;
    }

    function makeUI() {
      //uiContainer.renderOrder = 2;
      scene.add(uiContainer);

      const textPanel = new ThreeMeshUI.Block({
        width: 0.15,
        height: 0.15,
        //padding: 0.05,
        justifyContent: "center",
        textAlign: "left",
        fontFamily: "./fonts/Roboto-msdf.json",
        fontTexture: "./fonts/Roboto-msdf.png"
      });

      textPanel.position.set(0, -0.15, 0);

      uiContainer.add(textPanel);

      const title = new ThreeMeshUI.Block({
        width: 0.15,
        height: 0.05,
        justifyContent: "center",
        fontSize: 0.006,
        backgroundOpacity: 0,
      }).add(
        new ThreeMeshUI.Text({ content: "Type some text on the keyboard" })
      );
      
      for (let i = 0; i < 3; i++) {
        userTexts.push(new ThreeMeshUI.Text({ content: "The image shows a tortilla placed on a cutting board, which means you have completed step 1.\n" }));
      }
      
      const textField = new ThreeMeshUI.Block({
        width: 0.15,
        height: 0.2,
        fontSize: 0.006,
        padding: 0.012,
        backgroundOpacity: 0,
        //interLine: 0.05,
        //bestFit: 'shrink'
      })

      for (let i = 0; i < userTexts.length; i++) {
        textField.add(userTexts[i]);
      }

      textPanel.add(title, textField);
    }

    function init() {

      container = document.createElement('div');
      document.body.appendChild(container);

      // set up three.js boilerplate
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.xr.setFoveation(0);
      renderer.autoClear = false;
      container.appendChild(renderer.domElement);

      const sessionInit = {
				requiredFeatures: [ 'hand-tracking' ]
			};

      xrButton = new WebXRButton({
        onRequestSession: onRequestSession,
        onEndSession: onEndSession,
        textEnterXRTitle: "START AR",
        textXRNotFoundTitle: "AR NOT FOUND",
        textExitXRTitle: "EXIT AR",
      });

      document.querySelector('header').appendChild(xrButton.domElement);

      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar')
          .then((supported) => {
            xrButton.enabled = supported;
          });
      }

      // // add controllers to the scene
      // controller1 = renderer.xr.getController(0);
      // controller1.addEventListener('selectstart', onSelectStart);
      // controller1.addEventListener('selectend', onSelectEnd);
      // controller1.addEventListener('connected', function (event) {
      //   this.add(buildController(event.data));
      // });

      // controller1.addEventListener('disconnected', function () {
      //   this.remove(this.children[0]);
      // });

      // scene.add(controller1);

      // controller2 = renderer.xr.getController(1);
      // controller2.addEventListener('selectstart', onSelectStart);
      // controller2.addEventListener('selectend', onSelectEnd);
      // controller2.addEventListener('connected', function (event) {
      //   this.add(buildController(event.data));
      // });

      // scene.add(controller2);

      // const controllerModelFactory = new XRControllerModelFactory();

      // controllerGrip1 = renderer.xr.getControllerGrip(0);
      // controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      // scene.add(controllerGrip1);

      // controllerGrip2 = renderer.xr.getControllerGrip(1);
      // controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      // scene.add(controllerGrip2);

      // controller2.addEventListener('disconnected', function () {
      //   this.remove(this.children[0]);
      // });
      // scene.add(controller2);

      ////////////////
      // Controllers
      ////////////////

      // vrControl = VRControl( renderer, camera, scene );

      // scene.add( vrControl.controllerGrips[ 0 ], vrControl.controllers[ 0 ] );

      // vrControl.controllers[ 0 ].addEventListener( 'selectstart', () => {

      //   selectState = true;

      // } );
      // vrControl.controllers[ 0 ].addEventListener( 'selectend', () => {

      //   selectState = false;

      // } );

      // controllers
			const controller1 = renderer.xr.getController( 0 );
			scene.add( controller1 );

			const controller2 = renderer.xr.getController( 1 );
			scene.add( controller2 );

			const controllerModelFactory = new XRControllerModelFactory();

			// Hand 1
			const controllerGrip1 = renderer.xr.getControllerGrip( 0 );
			controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
			scene.add( controllerGrip1 );

			const hand1 = renderer.xr.getHand( 0 );
			const handModel1 = new OculusHandModel( hand1 );
			hand1.add( handModel1 );
      handModel1.visible = false;
			scene.add( hand1 );

			// Hand 2
			const controllerGrip2 = renderer.xr.getControllerGrip( 1 );
			controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
			scene.add( controllerGrip2 );

			const hand2 = renderer.xr.getHand( 1 );
			const handModel2 = new OculusHandModel( hand2 );
			hand2.add( handModel2 );
      handModel2.visible = false;
			scene.add( hand2 );


      // buttons

			const consoleGeometry = new THREE.BoxGeometry( 0.5, 0.12, 0.15 );
			const consoleMaterial = new THREE.MeshPhongMaterial( { color: 0x595959 } );
			const consoleMesh = new THREE.Mesh( consoleGeometry, consoleMaterial );
			consoleMesh.position.set( 0, 1, - 0.3 );
			consoleMesh.castShadow = true;
			consoleMesh.receiveShadow = true;
			scene.add( consoleMesh );
      consoleMesh.visible = false;

			const orangeButton = makeButtonMesh( 0.08*0.25, 0.1*0.25, 0.08*0.25, 0xffd3b5 );
			orangeButton.position.set(-0.06, 0.03, 0);
			buttonGroup.add( orangeButton );
      orangeButton.visible = false;

			const pinkButton = makeButtonMesh( 0.08*0.25, 0.1*0.25, 0.08*0.25, 0xe84a5f );
			pinkButton.position.set(0.06, 0.03, 0);
			buttonGroup.add( pinkButton );
      pinkButton.visible = false;
      buttonGroup.rotation.x = Math.PI / 2;

			const resetButton = makeButtonMesh( 0.08, 0.1, 0.08, 0x355c7d );
			const resetButtonText = createText( 'reset', 0.03 );
			resetButton.add( resetButtonText );
			resetButtonText.rotation.x = - Math.PI / 2;
			resetButtonText.position.set( 0, 0.051, 0 );
			resetButton.position.set( 0.05, 0.04, 0 );
			//consoleMesh.add( resetButton );
      resetButton.visible = false;

			const exitButton = makeButtonMesh( 0.08, 0.1, 0.08, 0xff0000 );
			const exitButtonText = createText( 'exit', 0.03 );
			exitButton.add( exitButtonText );
			exitButtonText.rotation.x = - Math.PI / 2;
			exitButtonText.position.set( 0, 0.051, 0 );
			exitButton.position.set( 0.15, 0.04, 0 );
			//consoleMesh.add( exitButton );
      exitButton.visible = false;

			const tkGeometry = new THREE.TorusKnotGeometry( 0.5, 0.2, 200, 32 );
			const tkMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
			tkMaterial.metalness = 0.8;
			const torusKnot = new THREE.Mesh( tkGeometry, tkMaterial );
			torusKnot.position.set( 0, 1, - 5 );
			//scene.add( torusKnot );

			const instructionText = createText( 'This is a WebXR Hands demo, please explore with hands.', 0.04 );
			instructionText.position.set( 0, 1.6, - 0.6 );
			//scene.add( instructionText );

			const exitText = createText( 'Exiting session...', 0.04 );
			exitText.position.set( 0, 1.5, - 0.6 );
			exitText.visible = false;
			//scene.add( exitText );

			world
				.registerComponent( Object3D )
				.registerComponent( Button )
				.registerComponent( Pressable )
				.registerComponent( Rotating )
				.registerComponent( HandsInstructionText )
				.registerComponent( OffsetFromCamera )
				.registerComponent( NeedCalibration );

			world
				.registerSystem( RotatingSystem )
				.registerSystem( InstructionSystem, { controllers: [ controllerGrip1, controllerGrip2 ] } )
				.registerSystem( CalibrationSystem, { renderer: renderer, camera: camera } )
				.registerSystem( ButtonSystem, { renderer: renderer, camera: camera } )
				.registerSystem( FingerInputSystem, { hands: [ handModel1, handModel2 ] } );

			const csEntity = world.createEntity();
			csEntity.addComponent( OffsetFromCamera, { x: 0, y: - 0.4, z: - 0.3 } );
			csEntity.addComponent( NeedCalibration );
			csEntity.addComponent( Object3D, { object: consoleMesh } );

			const obEntity = world.createEntity();
			obEntity.addComponent( Pressable );
			obEntity.addComponent( Object3D, { object: orangeButton } );
			const obAction = function () {

				torusKnot.material.color.setHex( 0xffd3b5 );

			};

			obEntity.addComponent( Button, { action: obAction, surfaceY: 0.05, fullPressDistance: 0.02 } );

			const pbEntity = world.createEntity();
			pbEntity.addComponent( Pressable );
			pbEntity.addComponent( Object3D, { object: pinkButton } );
			const pbAction = function () {

				torusKnot.material.color.setHex( 0xe84a5f );

			};

			pbEntity.addComponent( Button, { action: pbAction, surfaceY: 0.05, fullPressDistance: 0.02 } );

			const rbEntity = world.createEntity();
			rbEntity.addComponent( Pressable );
			rbEntity.addComponent( Object3D, { object: resetButton } );
			const rbAction = function () {

				torusKnot.material.color.setHex( 0xffffff );

			};

			rbEntity.addComponent( Button, { action: rbAction, surfaceY: 0.05, fullPressDistance: 0.02 } );

			const ebEntity = world.createEntity();
			ebEntity.addComponent( Pressable );
			ebEntity.addComponent( Object3D, { object: exitButton } );
			const ebAction = function () {

				exitText.visible = true;
				setTimeout( function () {

					exitText.visible = false; renderer.xr.getSession().end();

				}, 2000 );

			};

			ebEntity.addComponent( Button, { action: ebAction, surfaceY: 0.05, recoverySpeed: 0.2, fullPressDistance: 0.03 } );

			const tkEntity = world.createEntity();
			tkEntity.addComponent( Rotating );
			tkEntity.addComponent( Object3D, { object: torusKnot } );

			const itEntity = world.createEntity();
			itEntity.addComponent( HandsInstructionText );
			itEntity.addComponent( Object3D, { object: instructionText } );

      const planeGeometry = new THREE.PlaneGeometry(3.22, 2.48);
      const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
      plane = new THREE.Mesh(planeGeometry, planeMaterial);
      scene.add(plane);

      // ////////////////////
      // // Primitive Meshes
      // ////////////////////

      // meshContainer = new THREE.Group();
      // meshContainer.position.set( 0, 1, -1.9 );
      // scene.add( meshContainer );

      // //

      // const sphere = new THREE.Mesh(
      //   new THREE.IcosahedronBufferGeometry( 0.3, 1 ),
      //   new THREE.MeshStandardMaterial( { color: 0x3de364, flatShading: true } )
      // );

      // const box = new THREE.Mesh(
      //   new THREE.BoxBufferGeometry( 0.45, 0.45, 0.45 ),
      //   new THREE.MeshStandardMaterial( { color: 0x643de3, flatShading: true } )
      // );

      // const cone = new THREE.Mesh(
      //   new THREE.ConeBufferGeometry( 0.28, 0.5, 10 ),
      //   new THREE.MeshStandardMaterial( { color: 0xe33d4e, flatShading: true } )
      // );

      // //

      // sphere.visible = box.visible = cone.visible = false;

      // meshContainer.add( sphere, box, cone );

      // meshes = [ sphere, box, cone ];
      // currentMesh = 0;

      // showMesh( currentMesh );




      //mediapipeCanvas = document.getElementById("mediapipe-canvas");
      //ctx = mediapipeCanvas.getContext("2d", { alpha: true });
      // drawingUtils = new DrawingUtils(ctx);
      // window.drawingUtils = drawingUtils;
      
      scene.add(uiGroup);
      scene.add(buttonGroup);
      //makeUI();
      // Update UI with new hints
      clearGroup(uiGroup); // Clear existing UI elements
      makeTextPanel();
      //makePanel();

      updateState();

      window.addEventListener('resize', onWindowResize);
    }

    function buildController(data) {

      let geometry, material;

      switch (data.targetRayMode) {
        case 'tracked-pointer':
          geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
          geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));

          material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });

          return new THREE.Line(geometry, material);
        case 'gaze':
          geometry = new THREE.RingGeometry(0.02, 0.04, 32).translate(0, 0, - 1);
          material = new THREE.MeshBasicMaterial({ opacity: 0.5, transparent: true });
          return new THREE.Mesh(geometry, material);
      }
    }

    let pointer = undefined;

    function onSelectStart(event) {
      selectState = true;
      pointer = event.target;
    }
    function onSelectEnd(event) {
      selectState = false;
      pointer = undefined;
    }

    function draw() { // the original raycasting function
      if (pointer === undefined) {
        return;
      }


      let yOffset = 0; 
      textPlanes.forEach(textPlane => {
        scene.remove(textPlane);
        if (textPlane.geometry) textPlane.geometry.dispose();
        if (textPlane.material) textPlane.material.dispose();
      });
      textPlanes = [];

          
      // Process hints in reverse order to have the last one as the baseline
      jsonData.hintsHistory.slice().reverse().forEach((hint, index) => {
        const name = hint.hint;
        let a = 0; // 'a' remains constant to keep hints aligned vertically
        let b = 0; // 'b' is constant because we're manually adjusting the vertical offset

        const textPlane = createText(name, 0.0125);
        textPlane.matrixAutoUpdate = true;
        textPlane.visible = false;
        scene.add(textPlane);
        const raycaster = new THREE.Raycaster();

        raycaster.setFromCamera(new THREE.Vector2(a, b), camera);

        allMeshes.forEach((meshContext, mesh) => {
          const intersections = raycaster.intersectObject(meshContext.mesh);

          if (intersections.length > 0) {
            textPlane.visible = true;
            // Position the baseline hint, then adjust yOffset upwards for each subsequent hint
            textPlane.position.copy(intersections[0].point).add(new THREE.Vector3(0, yOffset, 0));
            textPlane.material.depthTest = false;
            textPlane.material.needsUpdate = true;
            textPlanes.push(textPlane);

            // Increment yOffset to move the next hint upwards
            yOffset += 0.02; // Adjust this value as needed for your spacing
          }
        });
      });
    }

    function onRequestSession() {
      let sessionInit = {
        requiredFeatures: ['hit-test', 'mesh-detection', 'hand-tracking'],
        optionalFeatures: [],
      };
      if (useDomOverlay.checked) {
        sessionInit.optionalFeatures.push('dom-overlay');
        sessionInit.domOverlay = { root: document.body };
      }
      navigator.xr.requestSession('immersive-ar', sessionInit).then((session) => {
        session.mode = 'immersive-ar';
        xrButton.setSession(session);
        onSessionStarted(session);
      });
    }

    function onSessionStarted(session) {
      useDomOverlay.disabled = true;
      session.addEventListener('end', onSessionEnded);

      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);

      renderer.setAnimationLoop(render);
    }

    function onEndSession(session) {
      session.end();
    }

    function onSessionEnded(event) {
      useDomOverlay.disabled = false;
      xrButton.setSession(null);

      renderer.setAnimationLoop(null);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 32).translate(0, 0.1, 0);

    function createGeometry(vertices, indices) {
      const geometry = new THREE.BufferGeometry();
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

      return geometry;
    }

    let meshId = 1;
    let allMeshes = new Map();
    // Iterate over the meshes array and compare to our internal state
    // This is the code that keeps track of the mesh state and adds them to the scene.
    function processMeshes(timestamp, frame) {
      const referenceSpace = renderer.xr.getReferenceSpace();

      if (frame.detectedMeshes) {
        allMeshes.forEach((meshContext, mesh) => {
          // if a previous mesh is no longer reported
          if (!frame.detectedMeshes.has(mesh)) {
            // mesh was removed
            allMeshes.delete(mesh);
            console.debug("Mesh no longer tracked, id=" + meshContext.id);

            scene.remove(meshContext.mesh);
            scene.remove(meshContext.wireframe);
          }
        });

        // compare all incoming meshes with our internal state
        frame.detectedMeshes.forEach(mesh => {
          const meshPose = frame.getPose(mesh.meshSpace, referenceSpace);
          let meshMesh;
          let wireframeMesh;

          // this is a mesh we've seen before
          if (allMeshes.has(mesh)) {
            // may have been updated:
            const meshContext = allMeshes.get(mesh);
            meshMesh = meshContext.mesh;
            wireframeMesh = meshContext.wireframe;

            if (meshContext.timestamp < mesh.lastChangedTime) {
              // the mesh was updated!
              meshContext.timestamp = mesh.lastChangedTime;

              const geometry = createGeometry(mesh.vertices, mesh.indices);
              meshContext.mesh.geometry.dispose();
              meshContext.mesh.geometry = geometry;
              meshContext.wireframe.geometry.dispose();
              meshContext.wireframe.geometry = geometry;
            }
          } else {
            // new mesh

            // Create geometry:
            const geometry = createGeometry(mesh.vertices, mesh.indices);

            //wireframeMaterial.depthTest = true;
            wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
            wireframeMesh.matrixAutoUpdate = false;
            scene.add(wireframeMesh);

            meshMesh = new THREE.Mesh(geometry,
              meshMaterials[meshId % meshMaterials.length]
            );
            //meshMesh.material.depthTest = true;
            meshMesh.matrixAutoUpdate = false;
            scene.add(meshMesh);
            const originGroup = baseOriginGroup.clone();
            originGroup.visible = false;

            meshMesh.add(originGroup);
            allMeshOrigins.push(originGroup);

            const meshContext = {
              id: meshId,
              timestamp: mesh.lastChangedTime,
              mesh: meshMesh,
              wireframe: wireframeMesh,
              origin: originGroup,
            };

            allMeshes.set(mesh, meshContext);
            console.debug("New mesh detected, id=" + meshId);
            meshId++;
          }

          if (meshPose) {
            meshMesh.visible = true;
            meshMesh.matrix.fromArray(meshPose.transform.matrix);
            wireframeMesh.visible = showMeshTriangles.checked;
            wireframeMesh.matrix.fromArray(meshPose.transform.matrix);
          } else {
            meshMesh.visible = false;
            wireframeMesh.visible = false;
          }
        });
      }
    }

    // function showMesh( id ) {
    //   meshes.forEach( ( mesh, i ) => {
    //     mesh.visible = i === id ? true : false;
    //   } );
    // }

    function makePanel() {
      // Create a panel with two buttons to switch between the three meshes
      // Container block, in which we put the two buttons.
      // We don't define width and height, it will be set automatically from the children's dimensions
      // Note that we set contentDirection: "row-reverse", in order to orient the buttons horizontally

      const container = new ThreeMeshUI.Block( {
        justifyContent: 'center',
        contentDirection: 'row-reverse',
        fontFamily: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.json',
        fontTexture: 'https://unpkg.com/three-mesh-ui/examples/assets/Roboto-msdf.png',
        fontSize: 0.07,
        padding: 0.02,
        borderRadius: 0.11
      } );

      container.position.set( 0, 0.6, -1.2 );
      container.rotation.x = -0.55;
      scene.add( container );

      // BUTTONS

      // We start by creating objects containing options that we will use with the two buttons,
      // in order to write less code.

      const buttonOptions = {
        width: 0.4,
        height: 0.15,
        justifyContent: 'center',
        offset: 0.05,
        margin: 0.02,
        borderRadius: 0.075
      };

      // Options for component.setupState().
      // It must contain a 'state' parameter, which you will refer to with component.setState( 'name-of-the-state' ).

      const hoveredStateAttributes = {
        state: 'hovered',
        attributes: {
          offset: 0.035,
          backgroundColor: new THREE.Color( 0x999999 ),
          backgroundOpacity: 1,
          fontColor: new THREE.Color( 0xffffff )
        },
      };

      const idleStateAttributes = {
        state: 'idle',
        attributes: {
          offset: 0.035,
          backgroundColor: new THREE.Color( 0x666666 ),
          backgroundOpacity: 0.3,
          fontColor: new THREE.Color( 0xffffff )
        },
      };

      // Buttons creation, with the options objects passed in parameters.

      const buttonNext = new ThreeMeshUI.Block( buttonOptions );
      const buttonPrevious = new ThreeMeshUI.Block( buttonOptions );

      // Add text to buttons

      buttonNext.add(
        new ThreeMeshUI.Text( { content: 'next' } )
      );

      buttonPrevious.add(
        new ThreeMeshUI.Text( { content: 'previous' } )
      );

      // Create states for the buttons.
      // In the loop, we will call component.setState( 'state-name' ) when mouse hover or click

      const selectedAttributes = {
        offset: 0.02,
        backgroundColor: new THREE.Color( 0x777777 ),
        fontColor: new THREE.Color( 0x222222 )
      };

      buttonNext.setupState( {
        state: 'selected',
        attributes: selectedAttributes,
        onSet: () => {

          currentMesh = ( currentMesh + 1 ) % 3;
          showMesh( currentMesh );

        }
      } );
      buttonNext.setupState( hoveredStateAttributes );
      buttonNext.setupState( idleStateAttributes );

      //

      buttonPrevious.setupState( {
        state: 'selected',
        attributes: selectedAttributes,
        onSet: () => {

          currentMesh -= 1;
          if ( currentMesh < 0 ) currentMesh = 2;
          showMesh( currentMesh );

        }
      } );
      buttonPrevious.setupState( hoveredStateAttributes );
      buttonPrevious.setupState( idleStateAttributes );

      //

      container.add( buttonNext, buttonPrevious );
      objsToTest.push( buttonNext, buttonPrevious );

    }

    // function updateButtons() {
    //   // Find closest intersecting object

    //   let intersect;

    //   if (renderer.xr.isPresenting) {
    //     vrControl.setFromController(0, raycaster.ray);

    //     intersect = raycast();

    //     // Position the little white dot at the end of the controller pointing ray
    //     if (intersect) vrControl.setPointerAt(0, intersect.point);
    //   } else if (mouse.x !== null && mouse.y !== null) {
    //     raycaster.setFromCamera(mouse, camera);

    //     intersect = raycast();
    //   }

    //   // Update targeted button state (if any)

    //   if (intersect && intersect.object.isUI) {
    //     if (selectState) {
    //       // Component.setState internally call component.set with the options you defined in component.setupState
    //       intersect.object.setState("selected");
    //     } else {
    //       // Component.setState internally call component.set with the options you defined in component.setupState
    //       intersect.object.setState("hovered");
    //     }
    //   }

    //   // Update non-targeted buttons state

    //   objsToTest.forEach((obj) => {
    //     if ((!intersect || obj !== intersect.object) && obj.isUI) {
    //       // Component.setState internally call component.set with the options you defined in component.setupState
    //       obj.setState("idle");
    //     }
    //   });
    // }

    //

    function raycast() {
      return objsToTest.reduce((closestIntersection, obj) => {
        const intersection = raycaster.intersectObject(obj, true);

        if (!intersection[0]) return closestIntersection;

        if (
          !closestIntersection ||
          intersection[0].distance < closestIntersection.distance
        ) {
          intersection[0].object = obj;

          return intersection[0];
        }

        return closestIntersection;
      }, null);
    }

    
    function render(timestamp, frame) {
      if (frame) {
        processMeshes(timestamp, frame);
        //draw();

        // Update text planes to face the camera but keep them horizontally level
        textPlanes.forEach(textPlane => {
          // Copy the camera's position to a temporary vector
          let tempPosition = new THREE.Vector3();
          camera.getWorldPosition(tempPosition);

          // Ignore the Y component of the camera and text plane positions for the lookAt calculation
          //tempPosition.y = textPlane.position.y;

          // Make the text plane face towards the camera's XZ projection
          textPlane.lookAt(tempPosition);
        });

        uiGroup.position.copy(camera.position);
        uiGroup.rotation.copy(camera.rotation);
        uiGroup.translateZ(-0.5);
        uiGroup.translateY(-0.1);
        uiGroup.translateX(-0.2);
        //rotate the uiGroup in the y axis 30 degrees
        uiGroup.rotateY(20 * Math.PI / 180);
        uiGroup.rotateX(-10 * Math.PI / 180);

        buttonGroup.position.copy(camera.position);
        buttonGroup.rotation.copy(camera.rotation);
        buttonGroup.translateZ(-0.5);
        buttonGroup.translateY(-0.1);
        buttonGroup.translateX(-0.2);
        //rotate the uiGroup in the y axis 30 degrees
        buttonGroup.rotateY(20 * Math.PI / 180);
        buttonGroup.rotateX(-10 * Math.PI / 180);


        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();
        
        if (plane && camera) {
          plane.position.copy(camera.position);
          plane.rotation.copy(camera.rotation);

          plane.translateZ(-2);
        }

        plane.visible = false;

        ThreeMeshUI.update();
        
        const delta = clock.getDelta();
        const elapsedTime = clock.elapsedTime;
        renderer.xr.updateCamera( camera );
        world.execute( delta, elapsedTime );
        renderer.render(scene, camera);

        //updateButtons();
      }
    }

  </script>
</body>

</html>